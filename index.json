[{"content":" 從 C# 視角學習 Swift : The Basic\n常數與變數 (Constants and Variables) # 1. 核心觀念 # 概念解說：Swift 非常強調安全性，因此在宣告儲存容器時，強制區分「不可變 (Immutable)」與「可變 (Mutable)」。這有助於編譯器優化並防止意外修改數據。 關鍵語法：let (常數), var (變數) 官方提示： 如果你的代碼中儲存的值不會改變，請務必使用 let 關鍵字宣告為常數。只有在需要改變值時才使用變數。\n2. 範例解析 # 文件原始碼：\nlet maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 var environment = \u0026#34;development\u0026#34; let maximumNumberOfLoginAttempts: Int // maximumNumberOfLoginAttempts 目前還沒有值 if environment == \u0026#34;development\u0026#34; { maximumNumberOfLoginAttempts = 100 } else { maximumNumberOfLoginAttempts = 10 } // 現在 maximumNumberOfLoginAttempts 有值了，可以被讀取 邏輯解說： 這段代碼展示了 let 與 var 的基本宣告。值得注意的是，let 宣告的常數不一定要在宣告的那一行立即賦值（如第二段範例），但必須保證在第一次讀取前「被賦值一次且僅一次」。\n3. C# 開發者視角 # 概念對應：\nSwift 的 var 對應 C# 的 var (或明確型別變數)。 Swift 的 let 概念上介於 C# 的 const 與 readonly 之間，但在區域變數的使用上，C# 沒有完全等價的「執行期不可變區域變數」關鍵字 (雖然 C# 的 const 必須是編譯期常數)。 C# 對照程式碼：\n// C# const int MaximumNumberOfLoginAttempts = 10; // 必須在編譯期確認數值 var currentLoginAttempt = 0; // C# 模擬 Swift 的延遲初始化常數 (C# 無法直接對區域變數做唯讀強制檢查) int maxLoginAttempts; var environment = \u0026#34;development\u0026#34;; if (environment == \u0026#34;development\u0026#34;) { maxLoginAttempts = 100; } else { maxLoginAttempts = 10; } // 在 C# 中，maxLoginAttempts 之後仍可被修改，這就是安全性差異 關鍵差異分析：\n語法面：Swift 用 let 和 var 兩個關鍵字統治所有宣告；C# 則常混用 var、const、readonly 和明確型別。 行為面：Swift 的 let 允許「執行期計算 (Runtime evaluation)」，只要保證賦值一次即可。C# 的 const 必須是「編譯期常數 (Compile-time constant)」。這讓 Swift 的 let 比 C# 的 const 更有彈性且常用。 型別標註與推斷 (Type Safety and Inference) # 1. 核心觀念 # 概念解說：Swift 是強型別語言 (Type Safe)。你可以明確告訴編譯器變數是什麼型別 (Type Annotation)，也可以讓編譯器根據初始值自動猜測 (Type Inference)。 關鍵語法：: (冒號後接型別), String, Int, Double 2. 範例解析 # 文件原始碼：\nvar welcomeMessage: String welcomeMessage = \u0026#34;Hello\u0026#34; var x = 0.0, y = 0.0, z = 0.0 // 推斷為 Double let meaningOfLife = 42 // 推斷為 Int let pi = 3.14159 // 推斷為 Double 邏輯解說： 當沒有提供初始值時（如 welcomeMessage），必須明確寫出 : String。若有初始值（如 meaningOfLife），編譯器會自動推斷。\n3. C# 開發者視角 # 概念對應：這與 C# 的型別系統幾乎一致。\nC# 對照程式碼：\n// C# string welcomeMessage; welcomeMessage = \u0026#34;Hello\u0026#34;; var x = 0.0; // 推斷為 double var meaningOfLife = 42; // 推斷為 int 關鍵差異分析：\n語法面：Swift 變數名稱在冒號前，型別在冒號後 (name: Type)；C# 是型別在前 (Type name)。 行為面：兩者的推斷機制 (Swift 的 Type Inference vs C# 的 var) 非常相似。但 Swift 對型別轉換更嚴格（完全不允許隱式轉換，詳見後文）。 數值型別與轉換 (Numeric Types and Conversion) # 1. 核心觀念 # 概念解說：Swift 提供了 Int、UInt、Double、Float 等數值型別。特別注意 Swift 不支援不同數值型別之間的「隱式轉換 (Implicit Conversion)」，即使是將整數放入浮點數變數也必須顯式轉換。 關鍵語法：Int.min, Int.max, Double(...), Int(...) 官方提示： 除非你需要特定大小的整數（如處理外部資料），否則請一律使用 Int。即使在 32 位元平台上，Int 也足夠涵蓋 -20 億到 20 億的範圍。\n2. 範例解析 # 文件原始碼：\nlet twoThousand: UInt16 = 2_000 let one: UInt8 = 1 let twoThousandAndOne = twoThousand + UInt16(one) // 必須手動轉換 let three = 3 let pointOneFourOneFiveNine = 0.14159 let pi = Double(three) + pointOneFourOneFiveNine // 整數轉浮點 邏輯解說： Swift 不允許將 UInt8 直接加到 UInt16 上，也不允許將 Int 與 Double 直接相加。必須使用構造函數（如 UInt16(one)）進行轉換，這其實是建立了一個新數值。\n3. C# 開發者視角 # 概念對應：C# 允許「擴大轉換 (Widening Conversions)」的隱式行為，但 Swift 完全禁止。\nC# 對照程式碼：\n// C# ushort twoThousand = 2000; byte one = 1; var result = twoThousand + one; // C# 自動隱式轉換，合法 int three = 3; double pointOne = 0.14159; var pi = three + pointOne; // C# 自動將 int 轉為 double，合法 關鍵差異分析：\n語法面：Swift 使用建構式語法 Type(value) 進行轉換；C# 使用轉型語法 (Type)value 或 Convert.ToType(value)。 行為面：這是 C# 開發者最容易遇到的編譯錯誤。C# 習慣 int + double 自動變 double，但在 Swift 中這會報錯。Swift 設計哲學認為隱式轉換是 Bug 的溫床。 型別細節： Swift 的 Int 取決於平台（64-bit 平台上是 64-bit）。 C# 的 int 永遠是 32-bit (Int32)。C# 9.0 後的 nint 才相當於 Swift 的 Int。 元組 (Tuples) # 1. 核心觀念 # 概念解說：Tuple 允許將多個值組合成一個複合值。非常適合用於函式回傳多個結果，而不需要為此建立一個新的 Struct 或 Class。 關鍵語法：(Val1, Val2), .0, .1, (name: Val) 2. 範例解析 # 文件原始碼：\nlet http404Error = (404, \u0026#34;Not Found\u0026#34;) let (statusCode, statusMessage) = http404Error print(\u0026#34;The status code is \\(statusCode)\u0026#34;) // 使用索引存取 print(\u0026#34;The status code is \\(http404Error.0)\u0026#34;) // 命名元素 let http200Status = (statusCode: 200, description: \u0026#34;OK\u0026#34;) print(\u0026#34;The status code is \\(http200Status.statusCode)\u0026#34;) 邏輯解說： Tuples 可以解構 (Decompose) 成單獨的常數，也可以透過索引 (.0) 或標籤名稱 (.statusCode) 存取。\n3. C# 開發者視角 # 概念對應：對應現代 C# (C# 7.0+) 的 ValueTuple。\nC# 對照程式碼：\n// C# var http404Error = (404, \u0026#34;Not Found\u0026#34;); var (statusCode, statusMessage) = http404Error; // 解構 // 命名元素 var http200Status = (StatusCode: 200, Description: \u0026#34;OK\u0026#34;); Console.WriteLine(http200Status.StatusCode); 關鍵差異分析：\n語法面：兩者語法驚人地相似。 行為面：Swift 的 Tuple 和 C# 的 ValueTuple 都是 Value Type。但 Swift 官方建議 Tuple 僅用於臨時數據組合（如函式回傳），若資料結構複雜，應轉用 struct 或 class。 選項型別 (Optionals) # 1. 核心觀念 # 概念解說：這是 Swift 最重要的特性。Optional 代表「可能有值，也可能完全沒有值 (nil)」。Swift 的普通型別（如 Int, String）絕對不能是 nil。要處理缺失值，必須加上 ? 變成 Optional。 關鍵語法：Type?, nil, if let, !, ?? 官方提示： 在 Objective-C 中，nil 指向一個不存在的物件指標；在 Swift 中，nil 不是指標，而是代表「值不存在 (Absence of a value)」的一種狀態。任何型別（包括 Int）都可以是 Optional。\n2. 範例解析 # 文件原始碼：\nvar serverResponseCode: Int? = 404 serverResponseCode = nil // 現在沒有值了 // Optional Binding (安全解包) if let actualNumber = Int(\u0026#34;123\u0026#34;) { print(\u0026#34;Has value: \\(actualNumber)\u0026#34;) } else { print(\u0026#34;Conversion failed\u0026#34;) } // Implicitly Unwrapped Optionals (隱式解包) let assumedString: String! = \u0026#34;Always has value\u0026#34; let implicitString: String = assumedString // 自動解包，不需 ! 邏輯解說：\nInt(\u0026quot;123\u0026quot;) 回傳的是 Int?，因為轉換可能失敗。 if let 是 Swift 特有的語法，用於檢查 Optional 是否有值，若有則解包並賦值給臨時常數 actualNumber，該常數在 if 區塊內是安全的非 Optional 型別。 String! 用於那些「宣告後保證一直有值」的情況（如 UI 元件初始化後），使用時不用每次都解包，但若為 nil 會導致 Crash。 3. C# 開發者視角 # 概念對應：\n類似 C# 的 Nullable\u0026lt;T\u0026gt; (int?) 以及 C# 8.0+ 的 Nullable Reference Types (string?)。 但 Swift 的 Optional 實作上是一個 Enum (Case None, Case Some(Wrapped)). C# 對照程式碼：\n// C# int? serverResponseCode = 404; serverResponseCode = null; // C# 模式匹配 (類似 Swift 的 if let) string possibleNumber = \u0026#34;123\u0026#34;; if (int.TryParse(possibleNumber, out int actualNumber)) { Console.WriteLine($\u0026#34;Has value: {actualNumber}\u0026#34;); } // 或者對於 Nullable Types if (serverResponseCode is int code) { // code 在此處為 int，非 int? } // C# 沒有 Implicitly Unwrapped Optionals (!) 的直接對應 // 通常用 string! 告訴編譯器 \u0026#34;我知道這不是 null\u0026#34; (Null-forgiving operator) 關鍵差異分析：\n語法面：Swift 的 if let x = opt 語法非常簡潔。C# 需要使用 is 模式匹配 if (opt is {} x) 來達到類似效果。 行為面： C# 的 Reference Types 預設仍可能為 null (除非開啟 nullable context 並忽略警告)，Runtime 仍可能拋出 NullReferenceException。 Swift 透過編譯器強制檢查，如果不解包 (Unwrap) 就無法使用 Optional 裡面的值，從根本上杜絕了意外的 Null Reference 錯誤。 強制解包：Swift 的 ! (Force Unwrap) 若遇上 nil 會直接 Crash；類似 C# 的 .Value 存取但在空值時拋出異常。 錯誤處理 (Error Handling) # 1. 核心觀念 # 概念解說：Swift 使用 throws、try、do-catch 來處理可預期的錯誤。這與 Optionals 不同，Optionals 處理「值的缺失」，Error Handling 處理「操作失敗的原因」。 關鍵語法：throws, try, do { ... } catch { ... } 2. 範例解析 # 文件原始碼：\nfunc makeASandwich() throws { // ... 可能拋出錯誤 } do { try makeASandwich() eatASandwich() } catch SandwichError.outOfCleanDishes { washDishes() } catch SandwichError.missingIngredients(let ingredients) { buyGroceries(ingredients) } 邏輯解說： 函式宣告 throws 表示它可能會失敗。呼叫時必須在前面加 try，並包在 do-catch 區塊中處理異常。Swift 的錯誤通常是 Enum，可以攜帶關聯值（如 missingIngredients 帶出的清單）。\n3. C# 開發者視角 # 概念對應：對應 C# 的 try-catch 機制。\nC# 對照程式碼：\n// C# void MakeASandwich() { // ... throw new Exception(...) } try { MakeASandwich(); EatASandwich(); } catch (OutOfCleanDishesException) { WashDishes(); } catch (MissingIngredientsException ex) { BuyGroceries(ex.Ingredients); } 關鍵差異分析：\n語法面：Swift 要求在呼叫點明確寫出 try，這讓開發者一眼就能看出哪行程式碼可能拋出錯誤，C# 則隱式拋出。 行為面：C# 的 Exception 是昂貴的物件（包含 Stack Trace）；Swift 的 Error 通常是輕量級的 Struct 或 Enum，效能開銷極低，因此在 Swift 中用 Error 做流程控制是可以接受的。 斷言與前置條件 (Assertions and Preconditions) # 1. 核心觀念 # 概念解說：用於執行期間檢查邏輯假設。如果條件為 false，程式會終止。這是除錯與確保程式狀態正確的重要工具。 關鍵語法：assert (僅 Debug 模式生效), precondition (Debug 與 Release 皆生效) 2. 範例解析 # 文件原始碼：\nlet age = -3 assert(age \u0026gt;= 0, \u0026#34;A person\u0026#39;s age can\u0026#39;t be less than zero.\u0026#34;) // 在 Debug 模式下會觸發 Crash // Index 檢查 precondition(index \u0026gt; 0, \u0026#34;Index must be greater than zero.\u0026#34;) 3. C# 開發者視角 # 概念對應：\nSwift assert 對應 C# Debug.Assert。 Swift precondition 對應 C# Trace.Assert 或手動 if (!cond) throw ...。 C# 對照程式碼：\n// C# using System.Diagnostics; int age = -3; Debug.Assert(age \u0026gt;= 0, \u0026#34;A person\u0026#39;s age can\u0026#39;t be less than zero.\u0026#34;); 關鍵差異分析：\nSwift 明確區分了「僅除錯用 (assert)」和「生產環境也要檢查 (precondition)」的語法，C# 通常依賴 System.Diagnostics 命名空間或合約 (Contracts) 來處理。 ","date":"22 January 2026","externalUrl":null,"permalink":"/dev/swift/from-csharp-to-swift/thebasics/","section":"Devs","summary":"","title":"[從C#到Swift] 01. The Basics","type":"dev"},{"content":"","date":"22 January 2026","externalUrl":null,"permalink":"/tags/c%23/","section":"Tags","summary":"","title":"C#","type":"tags"},{"content":"","date":"22 January 2026","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"22 January 2026","externalUrl":null,"permalink":"/dev/","section":"Devs","summary":"","title":"Devs","type":"dev"},{"content":"","date":"22 January 2026","externalUrl":null,"permalink":"/categories/from-c%23-to-swift/","section":"Categories","summary":"","title":"From C# to Swift","type":"categories"},{"content":"","date":"22 January 2026","externalUrl":null,"permalink":"/","section":"Shen-Chih Hsu","summary":"","title":"Shen-Chih Hsu","type":"page"},{"content":"","date":"22 January 2026","externalUrl":null,"permalink":"/tags/swift/","section":"Tags","summary":"","title":"Swift","type":"tags"},{"content":"","date":"22 January 2026","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"Blowfish","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/tags/cloudflare/","section":"Tags","summary":"","title":"Cloudflare","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/tags/github-pages/","section":"Tags","summary":"","title":"Github-Pages","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/tags/static-site/","section":"Tags","summary":"","title":"Static-Site","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/categories/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98/","section":"Categories","summary":"","title":"技術筆記","type":"categories"},{"content":" 這篇筆記整理了使用 Hugo（靜態網站生成器）搭配 Blowfish主題，管於 GitHub Pages，並在Cloudflare設定網域。\n準備 # 安裝 Node.js # Node.js: 前往 Node.js 官網 下載並安裝。 安裝 Hugo # Hugo (Windows): install Hugo\nwinget install Hugo.Hugo.Extended 安裝Blowfish工具 # 使用官方推薦的 CLI 工具來初始化主題，這能簡化很多依賴設定。\n提示：詳細步驟可參考 Blowfish 官方文檔。\n配置 # Blowfish基礎配置 # 開始\n配置\n站點級配置 (hugo.toml) # baseURL: 最關鍵的參數。 baseURL 必須被設置為最終的公開域名（例如 https://www.example.com/）。如果設置錯誤，部署後會導致 CSS/JS 路徑失效，網站變成「裸奔」狀態（樣式丟失）甚至出現 404 錯誤。\nlanguageCode: 設置為 zh-tw，這有利於 SEO 與瀏覽器翻譯識別。 目錄結構解析 # 目錄名稱 功能描述 重要性 config/ 存放配置文件 強烈建議拆分為多個檔案（如 languages.zh-tw.toml），以支持多語言配置。 content/ 存放文章內容 網站的靈魂。資料夾結構直接對應網址路徑。 static/ 存放靜態資源 這裡的檔案（如圖片、CNAME）會被原封不動複製到發布目錄。 assets/ 資源處理 存放需要的檔案。 多語言與選單 # 在 config/_default/languages.zh-tw.toml 中定義網站標題與作者資訊；在 menus.zh-tw.toml 中定義導航欄。利用 weight 參數控制排序，數值越小越靠前。\n自動化部署：GitHub Pages # 不需要每次手動 build 完再上傳，讓 GitHub Actions 代勞，實現「推代碼即部署」。\n建立 Workflow 檔案 # 官方文件\n請在專案根目錄建立檔案 .github/workflows/gh-pages.yml，並填入自動化部署的配置內容（定義 Build 與 Deploy 到 gh-pages 分支的流程）。\n注意需加入 jobs.build-deploy.permissions.contents : write ，否則 Action 會因權限不足而失敗。\n# .github/workflows/gh-pages.yml name: GitHub Pages on: push: branches: - main jobs: build-deploy: permissions: contents: write runs-on: ubuntu-24.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: gh-pages publish_dir: ./public .gitignore # 為了保持 Git 倉庫乾淨，請設定忽略生成目錄與暫存檔。\n# Hugo default output directory /public /resources/_gen # Hugo build lock .hugo_build.lock 簡易版的自動提交腳本 # 為了節省每次輸入 git 指令的時間，用一個簡單的 PowerShell 腳本 (deploy.ps1)：\nparam( [Parameter(Mandatory=$false)] [string]$msg = \u0026#34;Site update $(Get-Date -Format \u0026#39;yyyy-MM-dd HH:mm\u0026#39;)\u0026#34; ) # 執行 git add Write-Host \u0026#34;正在加入變更至暫存區 (git add)...\u0026#34; -ForegroundColor Cyan git add . # 檢查是否有變更需要提交 if ($(git status --porcelain)) { # 執行 git commit Write-Host \u0026#34;正在提交變更 (git commit)...\u0026#34; -ForegroundColor Cyan git commit -m \u0026#34;$msg\u0026#34; # 執行 git push Write-Host \u0026#34;正在推送至遠端 (git push)...\u0026#34; -ForegroundColor Cyan git push Write-Host \u0026#34;完成！\u0026#34; -ForegroundColor Green } else { Write-Host \u0026#34;沒有偵測到需要提交的變更。\u0026#34; -ForegroundColor Yellow } 設定 GitHub Pages 來源 # 將代碼推送到 GitHub 後，等待 Action 執行成功，接著必須手動啟用 Pages 服務：\n進入 GitHub Repo 的 Settings。 點擊左側側邊欄的 Pages。 在 Build and deployment 區域： Source: 選擇 Deploy from a branch。 Branch: 選擇 gh-pages 分支 (如果沒看到，請確認 Action 是否已成功跑完)。 Folder: 選擇 / (root)。 點擊 Save。 網域綁定：Cloudflare 與 CNAME # Cloudflare DNS 設定 # 購買網域後，使用 Cloudflare 來管理 DNS\nGithub教學\nApex Domain (根域名 example.com): 新增 4 筆 A 記錄，指向 GitHub Pages 的專用 IP：\n185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 Subdomain (子域名 www): 新增 1 筆 CNAME 記錄：\n名稱: www 內容: \u0026lt;你的GitHub用戶名\u0026gt;.github.io 關鍵一步：手動建立 CNAME 文件 # 這是一個極易被忽略！ 當你在 GitHub 網頁上設定 Custom Domain 後，GitHub 會自動產生一個 CNAME 檔。但因為我們的部署流程是「每次重新生成並覆蓋」，下一次 Hugo 部署時，這個檔案會被刪除，導致網域失效。\n解決方案： 必須在本地專案的 static/ 目錄下手動建立一個名為 CNAME 的檔案（無副檔名），內容只需一行，請填入你的網域，範例如下：\nexample.com **原理：**Hugo 在構建時，會將 static/ 目錄下的所有文件原封不動地複製到 ./public。這確保了每次 Action 構建後，CNAME 文件都會存在，從而持久化網域綁定配置。\nGitHub Pages 設定 # 回到 GitHub Repo 的 Settings \u0026gt; Pages \u0026gt; Custom domain，填入你的網域（如 example.com），等待 \u0026ldquo;DNS check successful\u0026rdquo;。\n總結與檢查清單 # 完成上述步驟後，你的網站應該已經順利上線了。最後，請對照這份清單進行最終確認：\nhugo.toml: baseURL 是否已改為你的正式網域？\nstatic/CNAME: 文件是否存在且內容正確？\nGitHub Settings: Pages 頁面是否顯示 \u0026ldquo;DNS check successful\u0026rdquo;？\n","date":"10 January 2026","externalUrl":null,"permalink":"/posts/notes/hugo-blowfish-github-pages-guide/","section":"Posts","summary":"","title":"從零開始 : Hugo + GitHub Pages + Cloudflare 架站筆記","type":"posts"},{"content":" 引言：你是在「閱讀」，還是在「被動接收」？ # 在這個資訊爆炸的時代，我們每天都在閱讀——社群貼文、新聞快訊、技術文件。但你是否曾有過這樣的經驗：花了好幾個小時讀完一本書，蓋上書本後卻腦袋一片空白，只記得「感覺很棒」，卻說不出具體的邏輯或應用？\n莫提默‧艾德勒（Mortimer J. Adler）與查理‧范多倫（Charles Van Doren）合著的經典之作《如何閱讀一本書》，一針見血地指出：「閱讀的重點不在客觀的文字，而在讀者主動解讀文字的過程。」\n如果不願意動用主動的態度，我們只是資訊的容器，而非知識的主人。這篇筆記將重新梳理書中的核心架構，帶你從「資訊獲取」進階到真正的「深度理解」。\n核心觀點一：閱讀是主動的「接球」遊戲 # 作者認為，閱讀是一件主動的事。完全的被動只能說是「認字」，而非「閱讀」。\n如果把寫作比喻為投手投球，閱讀就是捕手接球。你必須張開感官、動用記憶力，主動去捕捉作者想要傳達的訊息。若我們只是被動地掃視文字，就像是球飛過來了，我們卻站在原地不動，最終什麼也沒接到。\n我們必須區分兩種閱讀目標：\n為獲得資訊而讀：讀我們原本就讀得懂的東西，增加的是資訊量。 為求得理解而讀：讀那些我們略感吃力、必須深思熟慮才能懂的東西。 真正的學習發生在後者。 這是憑藉一己之力，將理解力從粗淺推進到深入的過程。\n核心觀點二：閱讀的四個層次 # 這本書最精華的部分，在於將閱讀分為四個漸進的層次。這不是四種獨立的方法，而是像洋蔥一樣，高層次包含了低層次的能力。\n1. 基礎閱讀 # 這是小學階段的目標，重點在於「認字」。能讀懂句子在說什麼，是所有閱讀的基石。\n2. 檢視閱讀 # 這是在有限時間內，抓出一本書重點的藝術。\n略讀：先看書名、序言、目錄、索引，快速翻閱與主題相關的篇章。 粗淺的閱讀：遇到難讀的書，先從頭到尾讀一遍，碰到不懂的地方不要停下來查詢或思索。 目的：這階段不求甚解，目標是發現這本書的「骨架」與「脈動」。 3. 分析閱讀 # 這是最完整、最優質的閱讀方式，也是將書本「吃透」的關鍵。作者提出了詳細的規則，我將其歸納為三個重點步驟：\n透視架構：用一句話或一段文字敘述整本書在談什麼（找出主題），並列出大綱（找出骨架）。 詮釋內容： 關鍵字（Terms）：找出與作者共通的詞彙，解決「定義」問題。 主旨（Propositions）：找出關鍵句，用自己的話重述作者的判斷。 論述（Arguments）：分析作者是用歸納法還是演繹法來證明觀點。 公正評斷：在說出「我同意」或「我反對」之前，你必須先說「我讀懂了」。反對時要有理有據（證明作者知識不足、知識錯誤、不合邏輯或分析不完整）。 4. 主題閱讀 # 這是閱讀的最高境界，也是專業研究者的必備技能。\n以「我」為主：這時，你關心的不是某一本書，而是「你自己想解決的問題」。 整合觀點：閱讀多本書，建立一套中立的詞彙，讓不同的作者在你的架構下進行對話。 釐清爭議：整理不同作者對同一議題的衝突觀點，最後建立你自己的結論。 核心觀點三：主動閱讀者的四個提問 # 要如何保持「主動」？作者建議在閱讀過程中，不斷自我提問：\n整體來說，這本書到底在談些什麼？（找出主題與核心） 作者細部說了什麼？怎麼說的？（找出主要的想法、聲明與論點） 這本書說的有道理嗎？是全部有道理，還是部份有道理？（進行批判性思考） 這本書跟你有什麼關係？（這是我認為最重要的一點，知識必須與生命經驗連結） 精選金句 # 「閱讀的藝術在於掌握住作者傳達的訊息。」\n「只有一種方式是真正的閱讀，不要有任何外力的幫助，就是要讀這本書，從模糊的概念到更清楚的理解為止。」\n「書成為你的一部分和你成為書的一部分是同一件事，就是要去寫下來。」\n「最能學習的讀者，也就是最能批判的讀者。」\n個人反思與總結：為什麼我們要寫筆記？ # 讀完這本書，我對「做筆記」這件事有了全新的理解。\n以前我認為做筆記是為了「紀錄」，怕忘記書裡的內容。但《如何閱讀一本書》告訴我，筆記是為了「對話」。\n書中提到：「必須要讀出言外之意，才會有更大的收穫。」當我們試著用自己的語言去重述作者的主旨（分析閱讀），或是將多本書的觀點打散重組（主題閱讀）時，我們就不再只是資訊的接收者，而是知識的生產者。\n如果你覺得一本書很難讀，那是好事，因為那代表你的理解力正在被「拉升」。\n給自己的行動指南：\n遇難不退：讀第一遍時，遇到不懂的專有名詞先跳過，不要打斷閱讀的流暢感（檢視閱讀）。 用自己的話說：如果我無法用自己的語言解釋一個概念，代表我根本沒懂，只是記住了作者的「字」。 建立輸出循環：就像現在這篇文章一樣，將閱讀筆記整理成有邏輯的部落格文章，是檢驗自己是否完成「分析閱讀」的最好方式。 閱讀，就是讓大腦去健身房重訓。願我們都能透過閱讀，讓生活過得格外豐富濃稠。\n","date":"12 February 2024","externalUrl":null,"permalink":"/posts/book/how-to-read-a-book/","section":"Posts","summary":"","title":"如何閱讀一本書","type":"posts"},{"content":"","date":"12 February 2024","externalUrl":null,"permalink":"/tags/%E5%A6%82%E4%BD%95%E9%96%B1%E8%AE%80%E4%B8%80%E6%9C%AC%E6%9B%B8/","section":"Tags","summary":"","title":"如何閱讀一本書","type":"tags"},{"content":"","date":"12 February 2024","externalUrl":null,"permalink":"/tags/%E6%9F%A5%E7%90%86%E8%8C%83%E5%A4%9A%E5%80%AB/","section":"Tags","summary":"","title":"查理‧范多倫","type":"tags"},{"content":"","date":"12 February 2024","externalUrl":null,"permalink":"/tags/%E8%8E%AB%E6%8F%90%E9%BB%98%E8%89%BE%E5%BE%B7%E5%8B%92/","section":"Tags","summary":"","title":"莫提默‧艾德勒","type":"tags"},{"content":"","date":"12 February 2024","externalUrl":null,"permalink":"/categories/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/","section":"Categories","summary":"","title":"閱讀筆記","type":"categories"},{"content":"","date":"5 February 2024","externalUrl":null,"permalink":"/tags/%E7%B4%8D%E7%93%A6%E7%88%BE/","section":"Tags","summary":"","title":"納瓦爾","type":"tags"},{"content":" 《納瓦爾寶典》並不是一本教你如何快速致富的工具書，而是一本關於「人生哲學」的指南 # 在這個資訊焦慮、每個人都急著想「變現」的時代，我們往往陷入了忙碌卻無效的循環。我們出賣時間換取金錢，卻發現財富自由遙遙無期；我們追求外在的物質滿足，卻發現內心的平靜越來越難獲得。\n核心觀點一：財富的本質與「把自己商品化」 # Naval 提出了一個震撼的觀點：「在還沒弄清楚自己應該努力的事情之前，你不應該把許多笨苦工當作磨練。」 努力只是必要條件，但「選擇」比努力更重要。\n1. 什麼是財富？ # 金錢只是轉移財富的工具，財富是你睡覺時也能幫你賺錢的資產（如程式碼、媒體內容、股票）。如果你必須親自到場才能賺錢，那你只是擁有一份工作，而不是擁有財富。\n2. 獨特知識 (Specific Knowledge) # 要在市場上勝出，你不能跟別人做一樣的事。你必須找到你的獨特知識：\n無法被輕易培訓：如果學校能教，別人就能輕易學會並取代你。 源於熱愛：對你來說像在玩樂，對別人來說卻是在工作。 實作中獲得：通常透過師徒制或自我探索，而非正規教育。 3. 三種槓桿 (Leverage) # 擁有獨特知識後，你需要槓桿來放大你的產出。Naval 將槓桿分為三類：\n勞動力槓桿：讓別人為你工作。這是最古老但也是最難管理的槓桿。 資本槓桿：用錢賺錢。這需要你有良好的判斷力來募集資金。 零邊際成本的槓桿（新時代的聖杯）： 程式碼 (Code)：寫軟體。 媒體 (Media)：寫書、部落格、錄製 Podcast、影片。 這兩者是**「無需許可」(Permissionless)** 的槓桿。你不需要別人的同意就能使用，且複製成本為零。\n總結公式：\n把自己商品化 = 獨特知識 + 責任 (Accountability) + 槓桿\n核心觀點二：培養判斷力與長期賽局 # 為什麼有些人能在關鍵時刻做出正確決定，而有些人總是忙於修正錯誤？差別在於判斷力。\n1. 判斷力勝過蠻力 # 在現代社會，方向正確比行動迅速更重要。巴菲特可能花一年思考，只用一天行動，但那天的行動能影響未來數十年。\n預留空白：在忙碌行程中留白，給自己思考的時間。 去除雜訊：避免自我意識 (Ego) 和情緒干擾決策。 基礎學科：學習微觀經濟學、賽局理論、心理學、數學和電腦科學。這些基礎知識能幫助你建立穩固的思維模型。 2. 玩長期的複利賽局 # 生命中所有的回報（財富、關係、知識）都來自複利。\n選擇戰場：選擇可以和長期夥伴一起玩長期賽局的產業。 誠信至上：選擇智商高、能力強，但最重要的是有誠信的合作夥伴。 避開負面：遠離憤世濟俗和悲觀的人，因為他們會讓悲劇成真。 核心觀點三：快樂是一種可以學習的技能 # 我們常誤以為快樂是達成目標後的獎賞，但 Naval 認為：「快樂是一種選擇，是一種高度個人化的能力。」\n1. 慾望的代價 # Naval 說出一句極具洞察力的話：\n「慾望是你跟自己訂下的契約：在得到想要的東西之前，你不會快樂。」\n我們不需要透過苦行僧的方式生活，但要意識到每一個慾望都是對當下平靜的干擾。選擇一個最重要的慾望去追求，然後對其他事物保持平靜。\n2. 活在當下 # 除了此時此刻，我們其實別無所有。焦慮通常來自對未來的擔憂，悔恨來自對過去的糾結。\n冥想：这是大腦的「間歇性斷食」與「除錯模式」。 改變、接受或離開：面對任何情況，你永遠只有這三種選擇。如果你不能改變它，也不能離開它，那就徹底接受它。 個人反思與總結 # 讀完《納瓦爾寶典》，最大的啟發在於**「槓桿」**觀念的轉變。\nNaval 提醒我們，人生的終極目標不是成為最富有的人，而是成為**「做自己生命的主人」**。願我們都能運用槓桿，拿回時間的自主權。\n","date":"5 February 2024","externalUrl":null,"permalink":"/posts/book/the-almanack-of-naval-ravikant/","section":"Posts","summary":"","title":"納瓦爾寶典","type":"posts"},{"content":"","date":"5 February 2024","externalUrl":null,"permalink":"/tags/%E7%B4%8D%E7%93%A6%E7%88%BE%E5%AF%B6%E5%85%B8/","section":"Tags","summary":"","title":"納瓦爾寶典","type":"tags"},{"content":" 《心流：最優體驗心理學》讀書筆記：掌控意識，重塑生活的幸福感 # 在這個物質生活飛速進步，但焦慮與空虛感卻日益蔓延的時代，我們該如何定義幸福？\n米哈里．契克森米哈伊（Mihaly Csikszentmihalyi）在《心流：最優體驗心理學》一書中給出了一個反直覺的答案：幸福與外在條件無關，而是取決於我們如何詮釋它。這是我在閱讀本書後，關於如何掌控意識、創造「最優體驗」的深度筆記。\n重新詮釋幸福與成功 # 許多人終其一生追求外在的成功標籤，卻往往在達到目標後感到失落。奧地利心理學家維克多．弗蘭克（Viktor Frankl）曾說過一句極具啟發性的話：\n「不要以成功為目標——當你越是針對它，以它為標的，就越容易錯過它。成功，就像幸福一樣，不是追求而來的；它是一個人全心全意投入一件事，而忘卻自我的副產物。」\n這正是「心流」（Flow）的核心概念。最美好的時刻，並非發生在放鬆休閒時，而是發生在一個人有意地將身體或心智能力發揮到極限，去完成某件有難度或有價值的事。\n在此過程中，我們會進入一種全神貫注、渾然忘我的境界。要達到這種境界，我們必須將全部的精神能量投注在一個「符合現實」的目標上，且自身的技能必須與行動相互配合。\n解析意識：資訊的秩序 # 意識並無神秘之處，它是生理作用的產物。我們可以將意識視為「經過刻意整理的資訊」。\n意識的力量： 人類的神經系統可以左右自己的狀態。不管外在環境如何，只要改變意識內容（轉念），就能改變快樂或痛苦的感受。 意圖（Intent）： 這是讓意識維持秩序的力量。它像磁場一樣，將我們的注意力導向特定事物。 注意力的循環： 注意力塑造了自我（例如：偶然注意到海洋之美），而自我反過來塑造注意力（開始刻意追求海洋生物學知識）。 處於最優體驗的人，會感到與目標一致的資訊不斷進入意識，精神能量源源不絕，不再自我懷疑。\n享樂 vs. 樂趣：生活品質的關鍵 # 改善生活品質有兩個策略：一是改變外在環境，二是改變體驗環境的方式。而後者往往更為關鍵，因為生活品質取決於我們如何看待自己與際遇。\n我們必須區分「享樂」與「樂趣」：\n享樂 (Pleasure)： 是一種生物需求或社會制約的滿足（如：吃大餐、看電視放鬆）。它能維持秩序，但無法創造新秩序。 樂趣 (Enjoyment)： 超乎原有的期待，具有向前發展的特性。它通常發生在從事一件艱難但有機會成功的事，能帶來新鮮感與成就感。 樂趣的八大要素 # 當活動具備以下特質時，最容易產生樂趣：\n從事一件艱難，但有機會成功的事（行動機會與個人能力相當）。 必須全神貫注。 有明確的目標。 有立即的回饋。 全心投入，忘卻平時的擔憂。 覺得對自己的行動有掌控權。 進入忘我境界（體驗結束後，自我感會更強烈）。 時間感扭曲（幾小時像幾分鐘，或反之）。 這就是所謂的「自成目標」（Autotelic）活動——活動本身即是目標，而非為了未來的某種獎賞。\n心流的觸發機制：挑戰與技能的黃金比例 # 心流之所以能讓人感到成長，是因為它迫使我們進入一個新的現實，使自我變得更複雜。觸發心流最關鍵的條件在於 「技能」與「挑戰」的匹配：\nA2 技能 \u0026gt; 挑戰： 感到無聊（Boredom）。 A3 挑戰 \u0026gt; 技能： 感到焦慮（Anxiety）。 A1、A4 技能 = 挑戰： 進入心流（Flow）。 當我們在活動中感到無聊，意味著我們該提高難度；感到焦慮，則意味著需要提升技能。這種動態平衡推動著我們不斷進步。\n培養「自得其樂」的性格 # 除了尋找適合的活動，培養一種能隨時重組意識的內在性格同樣重要。哲學家羅素（Bertrand Russell）曾描述這種狀態：\n「我學著無視自己的缺陷與存在；慢慢增加對外在事物的關注，像是世界的現狀、各種領域的知識、令我感興趣的人物。」\n家庭對心流能力的影響 # 研究發現，在「自成目標」家庭長大的孩子，更容易產生心流體驗。這樣的家庭具備五個特點：\n明確 (Clarity)： 孩子清楚知道父母的期待與回饋。 重心 (Centering)： 父母對孩子當下做的事感興趣，而非只關心未來的功利結果。 選擇 (Choice)： 孩子感覺自己擁有選擇權，並願承擔後果。 承諾 (Commitment)： 足夠的信任感讓孩子能放下防備，全心投入。 挑戰 (Challenge)： 父母提供複雜度逐漸提高的行動機會。 翻轉渾沌：將壓力轉化為力量 # 為什麼有些人遇到壓力會崩潰，有些人卻越挫越勇？關鍵在於是否具備將無助狀況轉換為可控心流活動的能力。\n這類人通常具備以下特質：\n不自覺的自信： 不堅持自己的目標非得凌駕一切，而是將自己視為環境的一部分，在此體系中盡責。這種謙卑的自信是強者的標誌。 焦點向外： 態度開放，保持客觀，不花時間自怨自艾，而是注意到環境中的可能性。 尋找解決之道： 聚焦於移除障礙，甚至調整目標以尋求和諧。 結語：創造意義 # 想要將生活的全部變成一場心流體驗，光懂得控制一時的意識狀態是不夠的。我們需要一個貫穿人生的整體目標。\n心流理論的最終任務，是在所做的每一件事上創造和諧。只要方向清楚，行動規則明確，並能讓我們專注投入，任何目標——無論大小——都能讓人的一生充滿意義，將人生整合成單一件宏大的心流活動。\n","date":"30 January 2024","externalUrl":null,"permalink":"/posts/book/flow/","section":"Posts","summary":"","title":"心流","type":"posts"},{"content":"","date":"30 January 2024","externalUrl":null,"permalink":"/tags/%E5%BF%83%E6%B5%81/","section":"Tags","summary":"","title":"心流","type":"tags"},{"content":"","date":"30 January 2024","externalUrl":null,"permalink":"/tags/%E7%B1%B3%E5%93%88%E9%87%8C%E5%A5%91%E5%85%8B%E6%A3%AE%E7%B1%B3%E5%93%88%E4%BC%8A/","section":"Tags","summary":"","title":"米哈里．契克森米哈伊","type":"tags"},{"content":" 叔本華《人生智慧箴言》讀書筆記：向內尋求的幸福哲學 # 前言 # 最近重讀了叔本華的《人生智慧箴言》（Aphorisms on the Wisdom of Life）。這本書並非探討深奧晦澀的形而上學，而是這位悲觀主義哲學家晚年對「如何幸福生存」最務實的建議。\n叔本華在書中冷靜地剖析了人性的弱點與世道的殘酷，並指出：人生在世，其實不是為了享受人生，而是為了度過它。 以下是我對這本書的重點筆記與思考整理。\n人的三大基本分類：幸福取決於「你是誰」 # 叔本華認為，人的命運與遭遇差別，取決於三項根本內容：\n人之所是（人格）： 指最廣義的人格，包含健康、力量、外貌、氣質、道德品格、心智及其培育。這是大自然賦予的，也是最本質的。 人之所有（財富）： 指各類物質財富與佔有物。 人的形象（名聲）： 一個人在他人眼中的樣子，包含名譽、地位與名聲。 核心洞見 # 「人之所是」是幸福的基石： 外在的財富與名聲（客體）由命運掌握，變動不居；但我們的主體（自我）是本質，不會改變。 世界的面貌取決於你的頭腦： 相同的外在事件，對不同的人有完全不同的影響。一個人生活在什麼樣的世界中，首先取決於他對世界的理解。 健康的壓倒性地位： 健康是第一位的佳品。所謂「健康的乞丐比病篤的國王更幸福」。 「我們力所能及的，唯有最大限度地利用我們的天賦人格。」\n關於痛苦與無聊 # 叔本華提出了一個著名的鐘擺理論：人生就是在「痛苦」與「無聊」之間擺盪。\n痛苦：源於缺乏（如貧困、窘迫）。 無聊：源於滿足（如平安、富足）。 當外在物質匱乏時，我們感到痛苦；當物質滿足後，若內心空虛，我們便感到無聊。 精神越豐富、越接近卓越的人，留給無聊的空間就越小。 唯有在閒暇時能無憂無慮地享受自己的意識與個性，才是真正的幸福；若無精神活動充實，閒暇就只是「活人的墳墓」。\n拔除肉中刺：降低對他人看法的敏感度 # 我們花費了太多生命在經營「人的形象」，這往往是幸福最大的敵人。\n內在 vs 外在： 我們真實的狀況（健康、家庭、心境）存在於我們自己的意識中；而名聲只存在於「別人的意識」中，對我們來說僅是間接存在。\n虛榮與驕傲的區別：\n驕傲：是發自內心的確信（相信自己有價值）。\n虛榮：是希望在他人心中喚起這種確信（從外部獲得評價）。\n最有效的幸福策略： 將對他人看法的關注度降到最低（例如降到目前的五十分之一）。這能拔掉時刻折磨我們的「肉中刺」。\n處世的具體忠告 # 關於生活態度 # 追求「無痛苦」而非「快樂」： 亞里斯多德說：「明智的人追求的是無痛苦，不是快樂。」快樂本質上是負面的（僅是慾望受阻的消除），而痛苦是正面的。要評估一個人多幸福，不該問什麼讓他快樂，而該問「什麼讓他悲傷」——讓他煩惱的事越微不足道，他的幸福度越高。 活在當下： 不要過分關注過去或未來，唯有「現在」真實不虛。 自足自樂： 能說出「我獨自承擔全部自我」的人，具備幸福的首要條件。 如何待人 # 人際關係充滿了無奈與偽裝，叔本華建議保持「謹慎」與「寬容」。\n接納與距離： 我們必須接納每個人的固有個性，因為他改變不了。但要記住，人只能理解與自己同層次的事物，大多數人「主觀透頂」，只關心與自己有關的事。 藏拙是智慧： 展現聰明才智並不會討人喜歡，反而會因為間接指責他人愚蠢而惹人厭惡。正如格拉希安所說：「要討人喜歡，唯一的辦法就是披上最蠢動物的皮。」 禮貌的本質： 禮貌是一種默契，彼此心照不宣地忽視對方的道德低下與心智貧困。 溝通的藝術： 不要反駁：因為無法說服一個人放棄他的謬誤。 不要糾正：即使出於善意也不要。 說話平淡：讓他人去領悟，不要訴諸感情。 應對命運 # 人生如棋： 命運負責發牌（決定事件），我們負責出牌（做出決定）。 運氣與變數： 萬事變動不居，禍福相依。幸運時不要欣喜若狂，厄運時不要悲痛欲絕。 勇氣： 除了明智，勇氣對幸福至關重要。 人生的不同時期 # 叔本華對人生的階段有著詩意而透徹的比喻：\n少年視角： 眼前是漫長無盡的未來。生活如詩歌，充滿直觀與鮮明的印象。 老年視角： 身後是短暫的過去。生活如哲學，充滿抽象的思考。 時間的流逝： 年齡越大，生命意識越薄弱，日子過得越快，就像一部看過千百遍的戲，熟視無睹。 晚年的解放： 只有到了晚年，才能真正獲得「無所敬畏」的平靜，看透世間榮華皆是虛妄。 結語 # 《人生智慧箴言》教導我們的，是一種向內尋求的智慧。\n我們往往向外尋求快樂，卻找到了教訓。真正的幸福，在於健康的身體、平靜的靈魂，以及對自身擁有的確認。如叔本華所言：「既無痛苦，也不覺無聊，本質上就實現了人世的幸福，因為其餘都是虛幻。」\n","date":"29 January 2024","externalUrl":null,"permalink":"/posts/book/schopenhauer-aphorisms-summary/","section":"Posts","summary":"","title":"人生智慧箴言","type":"posts"},{"content":"","date":"29 January 2024","externalUrl":null,"permalink":"/tags/%E5%8F%94%E6%9C%AC%E8%8F%AF/","section":"Tags","summary":"","title":"叔本華","type":"tags"},{"content":"","date":"29 January 2024","externalUrl":null,"permalink":"/tags/%E5%93%B2%E5%AD%B8/","section":"Tags","summary":"","title":"哲學","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]