[{"content":" 從 C# 視角學習 Swift Swift : Cloures\n閉包基礎 (Closure Expressions) # 1. 核心觀念 # 概念解說： 閉包 (Closures) 是自包含的程式碼區塊，可以在程式碼中被傳遞和使用。簡單來說，它就是一段「可以被變數儲存的邏輯」。Swift 的閉包可以捕獲 (Capture) 其定義上下文中的常數和變數。 Swift 的閉包表達式擁有極簡的語法風格，編譯器能進行強大的型別推斷，允許省略參數型別、括號，甚至使用簡寫參數名 ($0)。 關鍵語法：{ (parameters) -\u0026gt; ReturnType in statements }、in 關鍵字、$0、Trailing Closures 官方提示： Global functions (全域函式) 和 Nested functions (巢狀函式) 其實都是閉包的特例。Global functions 是有名字但不捕獲值的閉包；Nested functions 是有名字且能從外層函式捕獲值的閉包。\n2. 範例解析 # 文件原始碼：\n// 原始完整寫法 let names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] var reversedNames = names.sorted(by: { (s1: String, s2: String) -\u0026gt; Bool in return s1 \u0026gt; s2 }) // 優化 1: 型別推斷 (Type Inference) reversedNames = names.sorted(by: { s1, s2 in return s1 \u0026gt; s2 } ) // 優化 2: 單一表達式隱式回傳 (Implicit Returns) reversedNames = names.sorted(by: { s1, s2 in s1 \u0026gt; s2 } ) // 優化 3: 參數簡寫 (Shorthand Argument Names) reversedNames = names.sorted(by: { $0 \u0026gt; $1 } ) // 優化 4: 運算子方法 (Operator Methods) reversedNames = names.sorted(by: \u0026gt;) 邏輯解說： 這段程式碼展示了 Swift 閉包語法的演進過程。從最完整的函式型別宣告，一步步省略已知資訊。\n因為 sorted(by:) 預期接收 (String, String) -\u0026gt; Bool，所以參數型別 String 可以省略。 閉包內只有一行程式碼，return 關鍵字可以省略。 如果懶得命名參數 s1, s2，可以直接用 $0, $1 代表第一個與第二個參數。 因為 String 定義了 \u0026gt; 運算子，且其簽章剛好符合需求，可以直接傳入運算子。 3. C# 開發者視角 # 概念對應： Swift 的 Closures 直接對應 C# 的 Lambda Expressions (=\u0026gt;) 以及 Anonymous Methods (delegate { })。\nC# 對照程式碼：\nvar names = new List\u0026lt;string\u0026gt; { \u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34; }; // C# Lambda 表達式 // 對應 Swift 的 { s1, s2 in s1 \u0026gt; s2 } var reversedNames = names.OrderByDescending(s =\u0026gt; s).ToList(); // 若要完全模擬比較器邏輯： names.Sort((s1, s2) =\u0026gt; s2.CompareTo(s1)); 關鍵差異分析：\n語法面： Swift 使用 in 關鍵字來分隔參數與本體 ({ params in body })。 C# 使用 Lambda 運算子 =\u0026gt; (params =\u0026gt; body)。 Swift 提供 $0, $1 這種簡寫參數，C# 必須明確命名參數 (例如 x =\u0026gt; x + 1)，無法省略參數名。 行為面： 兩者在型別推斷上都非常強大，通常不需要顯式宣告參數型別。 尾隨閉包 (Trailing Closures) # 1. 核心觀念 # 概念解說： 如果函式的最後一個參數是閉包，Swift 允許你將閉包表達式寫在函式呼叫的括號 () 之外。這能讓程式碼看起來更像原生的控制結構 (如 if 或 while 區塊)，大幅提升可讀性。如果閉包是該函式的唯一參數，甚至連括號 () 都可以省略。 關鍵語法：funcName() { ... } 2. 範例解析 # 文件原始碼：\nfunc someFunctionThatTakesAClosure(closure: () -\u0026gt; Void) { // function body } // 不使用尾隨閉包 someFunctionThatTakesAClosure(closure: { // closure\u0026#39;s body }) // 使用尾隨閉包 (括號外) someFunctionThatTakesAClosure() { // trailing closure\u0026#39;s body } // 實際應用：Array map let strings = numbers.map { (number) -\u0026gt; String in var number = number var output = \u0026#34;\u0026#34; repeat { output = digitNames[number % 10]! + output number /= 10 } while number \u0026gt; 0 return output } 邏輯解說： map 函式接受一個閉包作為參數。因為它是唯一參數，呼叫時省略了 map(...) 的括號，直接接上 { ... }。這使得這段轉換邏輯看起來非常像一個獨立的程式區塊，而不是一個函式參數，這是 Swift 打造 DSL (領域特定語言) 感覺的關鍵特性。\n3. C# 開發者視角 # 概念對應： C# 沒有直接對應 Trailing Closures 的語法糖。在 C# 中，即使 Lambda 是最後一個參數，也必須寫在括號內。\nC# 對照程式碼：\n// C# 必須將 Lambda 包在括號內 var strings = numbers.Select(number =\u0026gt; { var tempNumber = number; var output = \u0026#34;\u0026#34;; // ... 邏輯 ... return output; }); 關鍵差異分析：\n語法面：這是 Swift 程式碼看起來比較「乾淨」的主因之一。C# 開發者在閱讀 Swift UI (SwiftUI) 或設定檔程式碼時，會發現大量的 Trailing Closure，要習慣這種「函式呼叫看起來像區塊定義」的寫法。 值捕獲 (Capturing Values) 與 記憶體管理 # 1. 核心觀念 # 概念解說： 閉包可以「捕獲」其定義範圍內的常數或變數，即使定義這些變數的原作用域已經結束，閉包依然可以參考並修改這些值。 Swift 的閉包是 Reference Type (參考型別)。當你將閉包賦值給變數時，你賦值的是參考。 關鍵語法：Reference Type, Capture List, makeIncrementer 官方提示： 如果你將閉包賦值給類別實例的屬性，而該閉包又捕獲了該實例 (透過 self)，會造成 Strong Reference Cycle (強參考循環)。Swift 使用 Capture List ([weak self]) 來打破這種循環。\n2. 範例解析 # 文件原始碼：\nfunc makeIncrementer(forIncrement amount: Int) -\u0026gt; () -\u0026gt; Int { var runningTotal = 0 func incrementer() -\u0026gt; Int { runningTotal += amount return runningTotal } return incrementer } let incrementByTen = makeIncrementer(forIncrement: 10) incrementByTen() // returns 10 incrementByTen() // returns 20 邏輯解說： incrementer 函式是巢狀在 makeIncrementer 裡面的。它捕獲了外層的 runningTotal 和 amount。即使 makeIncrementer 執行完畢返回了，runningTotal 的記憶體空間依然存在，因為 incrementByTen 這個閉包捕獲了 runningTotal 的儲存狀態，該狀態會隨閉包生命週期一同存在。\n3. C# 開發者視角 # 概念對應： 這與 C# 的 Closure 變數捕獲 機制幾乎完全相同。C# 編譯器會自動生成一個隱藏的類別 (Display Class) 來保存被捕獲的變數。\nC# 對照程式碼：\nFunc\u0026lt;int\u0026gt; MakeIncrementer(int amount) { int runningTotal = 0; return () =\u0026gt; { runningTotal += amount; return runningTotal; }; } var incrementByTen = MakeIncrementer(10); Console.WriteLine(incrementByTen()); // 10 關鍵差異分析：\n行為面 (記憶體管理)：這是最大的陷阱。 C# 使用 Garbage Collection (GC)。即使 Lambda 捕獲了 this，通常只要外部沒有參考，循環參考會被 GC 回收 (除非涉及到 Event Handler 等特定場景)。 Swift 使用 ARC (Automatic Reference Counting)。閉包預設會對捕獲的物件建立 Strong Reference。如果閉包捕獲了 self，而 self 又持有這個閉包 (例如儲存為屬性)，會導致 Memory Leak。C# 開發者寫 Swift 時，必須時刻注意是否需要使用 [weak self] 或 [unowned self]。 逃逸閉包 (Escaping Closures) # 1. 核心觀念 # 概念解說： 當一個閉包作為參數傳遞給函式，但在函式返回 之後 才被呼叫，這個閉包就稱為「逃逸 (Escape)」。最常見的場景是非同步操作的 Completion Handler。 在 Swift 中，閉包預設是 Non-Escaping (不逃逸) 的，這是一種效能優化。如果閉包需要逃逸，必須明確加上 @escaping 標籤。 關鍵語法：@escaping, completionHandler 2. 範例解析 # 文件原始碼：\nvar completionHandlers: [() -\u0026gt; Void] = [] func someFunctionWithEscapingClosure(completionHandler: @escaping () -\u0026gt; Void) { // 閉包被儲存在外部陣列，稍後才執行 -\u0026gt; 逃逸 completionHandlers.append(completionHandler) } func someFunctionWithNonescapingClosure(closure: () -\u0026gt; Void) { // 閉包在函式內直接執行完畢 -\u0026gt; 不逃逸 closure() } 邏輯解說： someFunctionWithEscapingClosure 將閉包加入到外部定義的 completionHandlers 陣列中。這意味著當函式執行結束後，閉包還存在於記憶體中，隨時可能被呼叫。編譯器強制要求標記 @escaping，提醒開發者這裡有潛在的記憶體管理風險 (特別是捕獲 self 時)。\n3. C# 開發者視角 # 概念對應： C# 沒有 @escaping 這種顯式區分。在 C# 中，所有的 Delegate/Lambda 都是物件 (Heap Allocated)，本質上都具備「逃逸」的能力。\n關鍵差異分析：\n語法面：@escaping 是 Swift 特有的語法強制要求。 行為面：Swift 預設 Non-Escaping 是為了優化 (可以分配在 Stack 上，不需要 Reference Counting)。C# 開發者需要習慣：如果你的 Callback 是非同步執行的，或者被儲存起來以後用，Swift 編譯器會報錯要求你加上 @escaping。 Self 的處理：對於 @escaping 閉包，Swift 強制要求在閉包內顯式寫出 self. (例如 self.x)，或是透過 Capture List 加入 [self]，目的是強迫開發者意識到這裡發生了捕獲，防止循環參考。 自動閉包 (Autoclosures) # 1. 核心觀念 # 概念解說： @autoclosure 是一種語法糖，它會自動將你傳入的「表達式」包裹成一個閉包，只能包裹「單一表達式」，不能是任意程式區塊，但不需要寫花括號 {}，。它通常用於 延遲執行 (Delayed Evaluation)。 關鍵語法：@autoclosure 官方提示： 過度使用 @autoclosure 會降低程式碼可讀性。使用者可能不知道傳入的參數不會立即被求值。\n2. 範例解析 # 文件原始碼：\n// 定義接受 autoclosure 的函式 func serve(customer customerProvider: @autoclosure () -\u0026gt; String) { print(\u0026#34;Now serving \\(customerProvider())!\u0026#34;) } var customersInLine = [\u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Daniella\u0026#34;] // 呼叫時看起來像傳入 String，但其實是傳入一個閉包 // customersInLine.remove(at: 0) 這行程式碼在 serve 內部呼叫 customerProvider() 時才會執行 serve(customer: customersInLine.remove(at: 0)) 邏輯解說： serve 函式的參數型別標記了 @autoclosure。當我們呼叫 serve(customer: customersInLine.remove(at: 0)) 時，Swift 並不會先執行 remove(at: 0) 然後傳結果進去，而是自動生成一個 { customersInLine.remove(at: 0) } 的閉包傳進去。這意味著如果 serve 函式內部決定不呼叫這個閉包，remove 動作就永遠不會發生。\n3. C# 開發者視角 # 概念對應： 這類似於 C# 的 Func\u0026lt;T\u0026gt; 或 Lazy\u0026lt;T\u0026gt;，但 C# 沒有自動將表達式轉為 Func\u0026lt;T\u0026gt; 的語法糖。C# 開發者最接近的體驗可能是 IQueryable 或 Expression Tree 的延遲執行，或是 Debug.Assert 的條件檢查。\nC# 對照程式碼：\n// C# 沒有 Autoclosure，必須顯式傳入 Func void Serve(Func\u0026lt;string\u0026gt; customerProvider) { Console.WriteLine($\u0026#34;Now serving {customerProvider()}!\u0026#34;); } // 呼叫時必須寫成 Lambda Serve(() =\u0026gt; { var name = customersInLine[0]; customersInLine.RemoveAt(0); return name; }); 關鍵差異分析：\n語法面：Swift 的 @autoclosure 讓函式呼叫看起來非常自然 (像傳值)，但行為卻是傳參考 (邏輯)。 行為面：常見於 assert 函式。例如 assert(condition, message)，message 部分只有在 condition 失敗時才需要運算 (可能包含字串串接等昂貴操作)。使用 @autoclosure 可以避免不必要的運算開銷。 ","date":"2026.01.27","externalUrl":null,"permalink":"/dev/swift/from-csharp-to-swift/closures/","section":"Devs","summary":"","title":"[從C#到Swift] 07. Closures","type":"dev"},{"content":"","date":"2026.01.27","externalUrl":null,"permalink":"/tags/c%23/","section":"Tags","summary":"","title":"C#","type":"tags"},{"content":"","date":"2026.01.27","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2026.01.27","externalUrl":null,"permalink":"/dev/","section":"Devs","summary":"","title":"Devs","type":"dev"},{"content":"","date":"2026.01.27","externalUrl":null,"permalink":"/categories/from-c%23-to-swift/","section":"Categories","summary":"","title":"From C# to Swift","type":"categories"},{"content":"","date":"2026.01.27","externalUrl":null,"permalink":"/","section":"Shen-Chih Hsu","summary":"","title":"Shen-Chih Hsu","type":"page"},{"content":"","date":"2026.01.27","externalUrl":null,"permalink":"/tags/swift/","section":"Tags","summary":"","title":"Swift","type":"tags"},{"content":"","date":"2026.01.27","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 從 C# 視角學習 Swift Swift : Functions\n定義與呼叫函式 (Defining and Calling Functions) # 1. 核心觀念 # 概念解說：函式是執行特定任務的獨立程式碼區塊。在 Swift 中，函式的語法非常靈活，從類似 C 語言的簡單風格，到類似 Objective-C 帶有詳細參數標籤的風格都能支援。每個函式都有一個型別，由參數型別與回傳型別組成。 關鍵語法：func, -\u0026gt;, return 官方提示： Note print(_:separator:terminator:) 函式的第一個參數沒有標籤，而其他參數因為有預設值所以是選填的。這些語法變化將在後續章節詳細討論。\n2. 範例解析 # 文件原始碼：\nfunc greet(person: String) -\u0026gt; String { let greeting = \u0026#34;Hello, \u0026#34; + person + \u0026#34;!\u0026#34; return greeting } print(greet(person: \u0026#34;Anna\u0026#34;)) // Prints \u0026#34;Hello, Anna!\u0026#34; 邏輯解說： 這段程式碼定義了一個名為 greet 的函式，它接收一個 String 型別的參數 person，並回傳一個 String。-\u0026gt; 符號用來指示回傳型別。呼叫時，必須寫出參數標籤 person: \u0026quot;Anna\u0026quot;。\n3. C# 開發者視角 # 概念對應：這相當於 C# 中的 Method 定義。\nC# 對照程式碼：\npublic string Greet(string person) { string greeting = \u0026#34;Hello, \u0026#34; + person + \u0026#34;!\u0026#34;; return greeting; } // 呼叫 Console.WriteLine(Greet(\u0026#34;Anna\u0026#34;)); // 通常不強制寫參數名 // 或者使用具名引數 Console.WriteLine(Greet(person: \u0026#34;Anna\u0026#34;)); 關鍵差異分析：\n語法面：Swift 使用 func 關鍵字，回傳型別寫在箭頭 -\u0026gt; 之後；C# 則是將回傳型別寫在方法名稱之前。 行為面：最顯著的差異在於呼叫習慣。Swift 預設要求在呼叫時寫出參數標籤（Argument Label），這讓程式碼讀起來像句子；C# 雖然支援具名引數 (Named Arguments)，但慣例上較少強制使用。 參數與回傳值 (Function Parameters and Return Values) # 1. 核心觀念 # 概念解說：Swift 的參數與回傳值非常彈性。支援無參數、多參數、無回傳值（實際上是回傳 Void），以及透過 Tuple 實現多重回傳值。 關鍵語法：Void, Tuple, Optional Tuple 官方提示： 嚴格來說，沒有定義回傳型別的函式仍然會回傳值。它們回傳一個特殊的 Void 型別值，這其實是一個空的 Tuple，寫作 ()。\n2. 範例解析 # 文件原始碼 (多重回傳值)：\nfunc minMax(array: [Int]) -\u0026gt; (min: Int, max: Int)? { if array.isEmpty { return nil } var currentMin = array[0] var currentMax = array[0] for value in array[1..\u0026lt;array.count] { if value \u0026lt; currentMin { currentMin = value } else if value \u0026gt; currentMax { currentMax = value } } return (currentMin, currentMax) } 邏輯解說： 此範例展示了如何使用 Tuple 一次回傳最大值與最小值。同時，回傳型別標記為 (min: Int, max: Int)?，表示這是一個「可選的 Tuple」(Optional Tuple)，當陣列為空時可以回傳 nil。\n3. C# 開發者視角 # 概念對應：C# 7.0 引入的 ValueTuple 與此非常相似。\nC# 對照程式碼：\n// C# 7.0+ Tuple 語法 public (int min, int max)? MinMax(int[] array) { if (array.Length == 0) return null; int currentMin = array[0]; int currentMax = array[0]; foreach (var value in array.Skip(1)) { if (value \u0026lt; currentMin) currentMin = value; else if (value \u0026gt; currentMax) currentMax = value; } return (currentMin, currentMax); } 關鍵差異分析：\n語法面：兩者語法驚人地相似。Swift 的 Void 對應 C# 的 void，但 Swift 的 Void 本質上是一個空 Tuple ()，而 C# 的 void 不是可傳遞的型別。 行為面：注意 Swift 的 Optional Tuple (Int, Int)? 代表整個 Tuple 可能不存在；這與 Tuple 內部包含 Optional (Int?, Int?) 是不同的概念。C# 的 Nullable\u0026lt;(int, int)\u0026gt; 行為類似。 隱式回傳 (Functions With an Implicit Return) # 1. 核心觀念 # 概念解說：如果函式的本體 (Body) 只有一行表達式 (Expression)，可以省略 return 關鍵字。 關鍵語法：Implicit Return 2. 範例解析 # 文件原始碼：\nfunc greeting(for person: String) -\u0026gt; String { \u0026#34;Hello, \u0026#34; + person + \u0026#34;!\u0026#34; } 邏輯解說： 編譯器會自動判斷最後一行的結果作為回傳值，使程式碼更簡潔。\n3. C# 開發者視角 # 概念對應：相當於 C# 的 Expression-bodied members。\nC# 對照程式碼：\npublic string Greeting(string person) =\u0026gt; \u0026#34;Hello, \u0026#34; + person + \u0026#34;!\u0026#34;; 關鍵差異分析：\n語法面：C# 使用 lambda 箭頭 =\u0026gt;；Swift 則是直接保留大括號 {} 但省略 return。 行為面：兩者概念完全一致，都是為了減少 boilerplate code。 參數標籤與名稱 (Function Argument Labels and Parameter Names) # 1. 核心觀念 # 概念解說：這是 Swift 最具特色的設計之一。每個參數有兩個名字： Argument Label (參數標籤)：在呼叫函式時使用，目的是讓呼叫語句讀起來像自然語言。 Parameter Name (參數名稱)：在函式內部實作時使用。 關鍵語法：ArgumentLabel ParameterName: Type, _ (省略標籤) 2. 範例解析 # 文件原始碼：\n// 指定標籤：呼叫用 from，內部用 hometown func greet(person: String, from hometown: String) -\u0026gt; String { return \u0026#34;Hello \\(person)! Glad you could visit from \\(hometown).\u0026#34; } print(greet(person: \u0026#34;Bill\u0026#34;, from: \u0026#34;Cupertino\u0026#34;)) // 省略標籤：使用 _ func someFunction(_ firstParameterName: Int, secondParameterName: Int) { ... } someFunction(1, secondParameterName: 2) 邏輯解說： greet 函式透過 from 讓呼叫端 greet(..., from: \u0026quot;Cupertino\u0026quot;) 讀起來極為流暢。若不希望強制寫標籤，可使用底線 _ 來省略，這在模仿 C 語言風格函式庫時很有用。\n3. C# 開發者視角 # 概念對應：C# 沒有直接對應的「內外分立」命名機制，C# 的參數名稱同時用於內部實作與具名引數呼叫。\nC# 對照程式碼：\n// C# 無法完全模擬 Swift 的 \u0026#34;from hometown\u0026#34; 語法 // 只能透過參數命名來盡量表達語意 public string Greet(string person, string from) { return $\u0026#34;Hello {person}! Glad you could visit from {from}.\u0026#34;; } // 呼叫 Greet(person: \u0026#34;Bill\u0026#34;, from: \u0026#34;Cupertino\u0026#34;); 關鍵差異分析：\n語法面：Swift 允許 func f(label name: Type)，C# 只有 void f(Type name)。 設計哲學：Swift 強調 API 的可讀性 (Call-site readability)，將「讀起來像英文句子」視為最高指導原則（源自 Objective-C 的遺產）。C# 開發者剛接觸時可能會覺得多寫一個標籤很冗餘，但習慣後會發現這對程式碼的自我解釋性 (Self-documenting) 極有幫助。 預設參數值 (Default Parameter Values) # 1. 核心觀念 # 概念解說：可以在定義函式時為參數提供預設值。呼叫時若省略該參數，則使用預設值。 關鍵語法：param: Type = value 2. 範例解析 # 文件原始碼：\nfunc someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) { // ... } someFunction(parameterWithoutDefault: 4) // parameterWithDefault 使用 12 3. C# 開發者視角 # 概念對應：完全對應 C# 的 Optional Arguments。\nC# 對照程式碼：\nvoid SomeFunction(int parameterWithoutDefault, int parameterWithDefault = 12) { ... } 關鍵差異分析：\n行為面：兩者機制幾乎相同。但在 Swift 中，通常建議將沒有預設值的參數放在前面，有預設值的放在後面（雖然 Swift 語法不強制，但這是好習慣），這一點與 C# 的規定（選用參數必須在必填參數之後）是一致的。 可變參數 (Variadic Parameters) # 1. 核心觀念 # 概念解說：允許函式接收零個或多個特定型別的值。目前僅允許一個 Variadic 參數，且必須放在參數列表的最後 關鍵語法：Type... 2. 範例解析 # 文件原始碼：\nfunc arithmeticMean(_ numbers: Double...) -\u0026gt; Double { var total: Double = 0 for number in numbers { total += number } return total / Double(numbers.count) } arithmeticMean(1, 2, 3, 4, 5) 邏輯解說： numbers 在函式內部會被視為一個 [Double] 陣列。\n3. C# 開發者視角 # 概念對應：對應 C# 的 params 關鍵字。\nC# 對照程式碼：\npublic double ArithmeticMean(params double[] numbers) { double total = 0; foreach (var number in numbers) { total += number; } return total / numbers.Length; } 關鍵差異分析：\n語法面：Swift 使用後綴 ...，C# 使用前綴 params 關鍵字。 行為面：Swift 目前僅允許一個 Variadic 參數，且必須放在參數列表的最後；C# 也有類似限制。 In-Out 參數 (In-Out Parameters) # 1. 核心觀念 # 概念解說：預設情況下，Swift 的函式參數是常數 (Constant)，不可在函式內修改。若需要修改傳入的變數並將結果反映回原變數，需使用 inout。 關鍵語法：inout, \u0026amp; 官方提示： In-out 參數不能有預設值，且 Variadic 參數不能標記為 inout。\n2. 範例解析 # 文件原始碼：\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) { let temporaryA = a a = b b = temporaryA } var someInt = 3 var anotherInt = 107 swapTwoInts(\u0026amp;someInt, \u0026amp;anotherInt) 邏輯解說： inout 關鍵字標示參數可被修改。在呼叫時，變數前必須加上 \u0026amp; 符號，明確表示這裡發生了記憶體位址/值的傳遞引用。\n3. C# 開發者視角 # 概念對應：對應 C# 的 ref 關鍵字。\nC# 對照程式碼：\npublic void SwapTwoInts(ref int a, ref int b) { int temporaryA = a; a = b; b = temporaryA; } int someInt = 3; int anotherInt = 107; SwapTwoInts(ref someInt, ref anotherInt); 關鍵差異分析：\n語法面：Swift 定義時用 inout，呼叫時用 \u0026amp;；C# 定義與呼叫都使用 ref。 行為面：兩者概念一致，都是為了讓 Value Type (如 Struct, Int) 能像 Reference Type 一樣被修改。注意 Swift 的 inout 行為在底層優化上稱為 \u0026ldquo;Copy-in Copy-out\u0026rdquo; (或是 Call by value result)，在多執行緒環境下可能與 C# 的直接記憶體位置引用 (ref) 行為有細微差異，但一般使用上可視為相同。 函式型別 (Function Types) # 1. 核心觀念 # 概念解說：在 Swift 中，函式是一級公民 (First-class citizen)。函式本身有型別，可以被指派給變數、作為參數傳遞，或作為回傳值。 關鍵語法：(ParamTypes) -\u0026gt; ReturnType 2. 範例解析 # 文件原始碼：\nfunc addTwoInts(_ a: Int, _ b: Int) -\u0026gt; Int { a + b } // 定義變數 mathFunction，其型別為「接受兩個 Int 並回傳 Int 的函式」 var mathFunction: (Int, Int) -\u0026gt; Int = addTwoInts print(\u0026#34;Result: \\(mathFunction(2, 3))\u0026#34;) // 函式作為參數 func printMathResult(_ mathFunction: (Int, Int) -\u0026gt; Int, _ a: Int, _ b: Int) { print(\u0026#34;Result: \\(mathFunction(a, b))\u0026#34;) } printMathResult(addTwoInts, 3, 5) 邏輯解說： mathFunction 變數儲存了 addTwoInts 函式的參考。這讓你可以動態抽換執行邏輯。\n3. C# 開發者視角 # 概念對應：對應 C# 的 Delegates (Func\u0026lt;\u0026gt;, Action\u0026lt;\u0026gt;)。\nC# 對照程式碼：\nint AddTwoInts(int a, int b) =\u0026gt; a + b; // 使用 Func 委派 Func\u0026lt;int, int, int\u0026gt; mathFunction = AddTwoInts; Console.WriteLine($\u0026#34;Result: {mathFunction(2, 3)}\u0026#34;); // 函式作為參數 public void PrintMathResult(Func\u0026lt;int, int, int\u0026gt; mathFunc, int a, int b) { Console.WriteLine($\u0026#34;Result: {mathFunc(a, b)}\u0026#34;); } 關鍵差異分析：\n語法面：Swift 的語法 (Int, Int) -\u0026gt; Int 比 C# 的 Func\u0026lt;int, int, int\u0026gt; 更直觀且易讀。 行為面：本質相同，都是指向程式碼區塊的參考。Swift 的語法糖讓 Functional Programming 的模式更容易被接受與實作。 巢狀函式 (Nested Functions) # 1. 核心觀念 # 概念解說：可以在一個函式內部定義另一個函式。內層函式可以存取外層函式的變數（閉包特性），並且可以被回傳給外部使用。 關鍵語法：Function scope 2. 範例解析 # 文件原始碼：\nfunc chooseStepFunction(backward: Bool) -\u0026gt; (Int) -\u0026gt; Int { func stepForward(input: Int) -\u0026gt; Int { return input + 1 } func stepBackward(input: Int) -\u0026gt; Int { return input - 1 } return backward ? stepBackward : stepForward } 邏輯解說： stepForward 與 stepBackward 被隱藏在 chooseStepFunction 內部，外部無法直接呼叫它們，保持了全域命名空間的乾淨。但它們可以作為回傳值傳遞出去。\n3. C# 開發者視角 # 概念對應：對應 C# 7.0 引入的 Local Functions。\nC# 對照程式碼：\npublic Func\u0026lt;int, int\u0026gt; ChooseStepFunction(bool backward) { int StepForward(int input) =\u0026gt; input + 1; int StepBackward(int input) =\u0026gt; input - 1; return backward ? (Func\u0026lt;int, int\u0026gt;)StepBackward : StepForward; } 關鍵差異分析：\n語法面：結構幾乎一樣。 行為面：兩者都支援 Closure (閉包) 特性，即內部函式可以捕獲 (Capture) 外部函式的變數狀態。這在撰寫複雜的演算法或遞迴邏輯時，能有效封裝輔助函式。 ","date":"2026.01.27","externalUrl":null,"permalink":"/dev/swift/from-csharp-to-swift/functions/","section":"Devs","summary":"","title":"[從C#到Swift] 06. Functions","type":"dev"},{"content":" 從 C# 視角學習 Swift Swift : Control Flow\nFor-In 迴圈 (For-In Loops) # 1. 核心觀念 # 概念解說：for-in 是 Swift 中最主要的遍歷語法。它用來遍歷序列（Sequence），例如陣列（Array）、字典（Dictionary）、數值範圍（Range）或字串（String）。它的語法比 C 語言風格的 for 迴圈更簡潔且安全。 關鍵語法：for-in, ... (閉區間), ..\u0026lt; (半開區間), stride, _ (忽略值) 官方提示： 字典（Dictionary）的內容本質上是無序的，因此遍歷它們並不保證檢索順序。這與插入順序無關。\n2. 範例解析 # 文件原始碼：\nlet names = [\u0026#34;Anna\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Brian\u0026#34;, \u0026#34;Jack\u0026#34;] for name in names { print(\u0026#34;Hello, \\(name)!\u0026#34;) } let numberOfLegs = [\u0026#34;spider\u0026#34;: 8, \u0026#34;ant\u0026#34;: 6, \u0026#34;cat\u0026#34;: 4] for (animalName, legCount) in numberOfLegs { print(\u0026#34;\\(animalName)s have \\(legCount) legs\u0026#34;) } for index in 1...5 { print(\u0026#34;\\(index) times 5 is \\(index * 5)\u0026#34;) } 邏輯解說：\n第一段展示遍歷陣列，name 是每次迭代中的常數。 第二段展示遍歷字典，Swift 將字典的每個元素視為一個 (key, value) 的 Tuple，我們可以直接在迴圈宣告時進行解構（Decomposition）。 第三段展示數值範圍遍歷，使用 ... 運算符表示包含頭尾的範圍。 3. C# 開發者視角 # 概念對應：相當於 C# 的 foreach 迴圈。\nC# 對照程式碼：\nvar names = new[] { \u0026#34;Anna\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Brian\u0026#34;, \u0026#34;Jack\u0026#34; }; foreach (var name in names) { Console.WriteLine($\u0026#34;Hello, {name}!\u0026#34;); } var numberOfLegs = new Dictionary\u0026lt;string, int\u0026gt; { {\u0026#34;spider\u0026#34;, 8}, {\u0026#34;ant\u0026#34;, 6}, {\u0026#34;cat\u0026#34;, 4} }; foreach (var kvp in numberOfLegs) { // C# 透過 KeyValuePair 存取 Console.WriteLine($\u0026#34;{kvp.Key}s have {kvp.Value} legs\u0026#34;); } // 或是 C# 7.0+ 解構 foreach (var (animal, legs) in numberOfLegs) { Console.WriteLine($\u0026#34;{animal}s have {legs} legs\u0026#34;); } foreach (var index in Enumerable.Range(1, 5)) { Console.WriteLine($\u0026#34;{index} times 5 is {index * 5}\u0026#34;); } 關鍵差異分析：\n語法面：Swift 的區間運算符 1...5 (閉區間) 和 0..\u0026lt;5 (不包含尾端) 非常直觀。C# 通常需要使用 Enumerable.Range 或傳統 for 迴圈。 行為面：Swift 的 for-in 中的迭代變數（如 index）預設是常數 (let)，在迴圈內不可修改。若不需要該變數，Swift 要求使用 _ 明確忽略未使用的值，主要目的是提升可讀性與避免誤用；是否產生實質效能優化則由編譯器決定。 While 迴圈 (While Loops) # 1. 核心觀念 # 概念解說：當迭代次數未知，直到特定條件滿足前需要重複執行時使用。Swift 提供兩種形式：while (先檢查條件) 和 repeat-while (後檢查條件)。 關鍵語法：while, repeat-while 官方提示： Swift 的 repeat-while 迴圈類似於其他語言中的 do-while 迴圈。\n2. 範例解析 # 文件原始碼：\n// While while square \u0026lt; finalSquare { // 遊戲邏輯... square += diceRoll } // Repeat-While repeat { // 遊戲邏輯... square += diceRoll } while square \u0026lt; finalSquare 邏輯解說：這段代碼演示了「蛇梯棋」遊戲的邏輯。while 會在執行區塊前先判斷條件；而 repeat-while 保證區塊內的程式碼至少執行一次，最後才檢查條件。\n3. C# 開發者視角 # 概念對應：完全對應 C# 的 while 和 do-while。\nC# 對照程式碼：\n// C# while (square \u0026lt; finalSquare) { // Logic } do { // Logic } while (square \u0026lt; finalSquare); 關鍵差異分析：\n語法面：Swift 使用關鍵字 repeat 來替代 C# 的 do。 行為面：行為邏輯完全一致。主要差異在於 Swift 的條件判斷式不需要像 C# 一樣強制加上小括號 ()，例如 while square \u0026lt; finalSquare 即可。 條件判斷 (Conditional Statements) # 1. 核心觀念 # 概念解說：Swift 的 if 不僅是語句，也可以作為表達式（Expression）回傳值。switch 則比 C# 傳統的 switch 強大許多，支援區間、Tuple 和模式匹配。 關鍵語法：if, else if, else 2. 範例解析 # 文件原始碼：\n// 標準用法 if temperatureInFahrenheit \u0026lt;= 32 { print(\u0026#34;It\u0026#39;s very cold.\u0026#34;) } // If Expression (賦值用法) let weatherAdvice = if temperatureInCelsius \u0026lt;= 0 { \u0026#34;It\u0026#39;s very cold. Consider wearing a scarf.\u0026#34; } else if temperatureInCelsius \u0026gt;= 30 { \u0026#34;It\u0026#39;s really warm. Don\u0026#39;t forget to wear sunscreen.\u0026#34; } else { \u0026#34;It\u0026#39;s not that cold. Wear a T-shirt.\u0026#34; } 邏輯解說：這裡展示了將 if 當作表達式使用，直接將判斷結果賦值給變數 weatherAdvice。這讓程式碼更簡潔，不需要先宣告變數再賦值。\n3. C# 開發者視角 # 概念對應：\n標準 if 對應 C# if。 if 表達式對應 C# 的三元運算子 ? : 或較新的 Switch Expression。 C# 對照程式碼：\n// C# 使用三元運算子達到類似 if expression 效果 var weatherAdvice = temperatureInCelsius \u0026lt;= 0 ? \u0026#34;It\u0026#39;s very cold...\u0026#34; : temperatureInCelsius \u0026gt;= 30 ? \u0026#34;It\u0026#39;s really warm...\u0026#34; : \u0026#34;It\u0026#39;s not that cold...\u0026#34;; 關鍵差異分析：\n語法面：Swift 的 if 條件不需要小括號 () 包覆，但執行區塊的大括號 {} 是強制的（即使只有一行代碼）。C# 允許單行省略大括號，Swift 不行。 行為面：Swift的 if 表達式比 C# 的巢狀三元運算子更具可讀性。 Switch 語句 (Switch) # 1. 核心觀念 # 概念解說：Swift 的 switch 極為強大。它必須是窮舉的 (Exhaustive)，也就是所有可能的情況都必須被處理（通常透過 default）。最重要的一點是：預設不貫穿 (No Implicit Fallthrough)。 關鍵語法：switch, case, default, ... (區間匹配), (a, b) (Tuple 匹配), let (數值綁定), where (額外條件) 官方提示： 雖然在 Swift 中 break 不是必須的，但你可以使用 break 語句來匹配並忽略某個特定的 case，或是用來提前跳出執行。 若需要 C 語言風格的貫穿行為，必須顯式使用 fallthrough 關鍵字。\n2. 範例解析 # 文件原始碼：\nlet somePoint = (1, 1) switch somePoint { case (0, 0): print(\u0026#34;origin\u0026#34;) case (_, 0): // 匹配任何 x 值，y 為 0 print(\u0026#34;on the x-axis\u0026#34;) case (0, _): // 匹配 x 為 0，任何 y 值 print(\u0026#34;on the y-axis\u0026#34;) case (-2...2, -2...2): // 區間匹配 print(\u0026#34;inside the box\u0026#34;) default: print(\u0026#34;outside\u0026#34;) } // 數值綁定與 Where 子句 let yetAnotherPoint = (1, -1) switch yetAnotherPoint { case let (x, y) where x == y: print(\u0026#34;on the line x == y\u0026#34;) case let (x, y) where x == -y: print(\u0026#34;on the line x == -y\u0026#34;) case let (x, y): print(\u0026#34;arbitrary point (\\(x), \\(y))\u0026#34;) } 邏輯解說：\n第一個範例展示了 Tuple 匹配和萬用字元 _。Swift 可以同時比對多個值。 第二個範例展示了「數值綁定」(Value Binding)，將匹配到的值暫存為常數 x, y，並透過 where 子句加上額外的邏輯判斷。 3. C# 開發者視角 # 概念對應：類似 C# 的 switch，尤其是 C# 8.0+ 引入的 Pattern Matching。\nC# 對照程式碼：\n// C# 8.0+ Pattern Matching var somePoint = (1, 1); switch (somePoint) { case (0, 0): Console.WriteLine(\u0026#34;origin\u0026#34;); break; case (var x, 0): // 類似 Swift 的 (_, 0) 但語法稍有不同 Console.WriteLine($\u0026#34;on x-axis at {x}\u0026#34;); break; case (0, _): Console.WriteLine(\u0026#34;on y-axis\u0026#34;); break; case (var x, var y) when x == y: // 對應 Swift 的 case let ... where Console.WriteLine(\u0026#34;x == y\u0026#34;); break; default: Console.WriteLine(\u0026#34;outside\u0026#34;); break; } 關鍵差異分析：\n語法面：Swift 不需要寫 break，這是最大的習慣差異。C# 即使是空的 case 也不能直接貫穿到下一個非空 case（除非用 goto case），Swift 則完全禁止隱式貫穿。 行為面：Swift 的 switch 必須處理所有可能性，這對 Enum 特別有用，當 Enum 新增成員時，編譯器會強迫你更新 switch 代碼，減少 Bug。 複合 Case：Swift 支援 case \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;: 這種寫法；C# 傳統上是堆疊 case 標籤，現代模式匹配也支援 or 邏輯。 控制轉移語句 (Control Transfer Statements) # 1. 核心觀念 # 概念解說：改變程式執行順序的語句。包括 continue (跳過本次迴圈)、break (跳出迴圈或 switch)、fallthrough (switch 貫穿)。 關鍵語法：continue, break, fallthrough, return, throw 2. 範例解析 # 文件原始碼：\nlet integerToDescribe = 5 var description = \u0026#34;The number \\(integerToDescribe) is\u0026#34; switch integerToDescribe { case 2, 3, 5, 7, 11, 13, 17, 19: description += \u0026#34; a prime number, and also\u0026#34; fallthrough // 顯式要求貫穿 default: description += \u0026#34; an integer.\u0026#34; } // 結果: \u0026#34;The number 5 is a prime number, and also an integer.\u0026#34; 邏輯解說：因為 Swift switch 預設匹配到一個 case 就會結束，若希望執行完 case 1 後繼續執行 case 2 (或 default) 的代碼，必須加上 fallthrough。\n3. C# 開發者視角 # 概念對應：\ncontinue / break 與 C# 行為一致。 fallthrough 對應 C# 的 goto case 或 goto default。 C# 對照程式碼：\nswitch (integerToDescribe) { case 2: case 3: // ... case 19: description += \u0026#34; a prime number, and also\u0026#34;; goto default; // C# 的顯式貫穿 default: description += \u0026#34; an integer.\u0026#34;; break; } 關鍵差異分析：\n語法面：Swift 的 fallthrough 不需要指定跳轉的目標，它直接「掉進」下一個 case 的執行區塊中，且不會檢查下一個 case 的條件，這點非常重要且容易產生 Bug，需謹慎使用。 帶標籤的語句 (Labeled Statements) # 1. 核心觀念 # 概念解說：當有多層巢狀迴圈時，可以使用標籤（Label）來指定 break 或 continue 作用於哪一層迴圈。 關鍵語法：labelName: while ... 2. 範例解析 # 文件原始碼：\ngameLoop: while square != finalSquare { diceRoll += 1 switch square + diceRoll { case finalSquare: break gameLoop // 直接跳出最外層的 while 迴圈，而不只是 switch // ... } } 邏輯解說：如果不加標籤，break 只會跳出 switch 語句。加上 gameLoop 標籤後，break gameLoop 會直接終止整個 while 迴圈。\n3. C# 開發者視角 # 概念對應：C# 也有 goto 標籤，但沒有這種直接綁定在迴圈結構上的 break label 語法。\nC# 對照程式碼：\n// C# 通常做法 bool keepPlaying = true; while (keepPlaying) { // ... switch (condition) { case 1: keepPlaying = false; // 使用旗標 break; // 或者使用 goto case 2: goto EndOfLoop; } } EndOfLoop: ; 關鍵差異分析：\n語法面 : Swift 的標籤語法比 C# 的 goto 更結構化且易讀，專門用於巢狀迴圈控制。 提前退出 (Guard) # 1. 核心觀念 # 概念解說：guard 是一種「反向 if」。它要求條件必須為真，否則執行 else 區塊。else 區塊內必須包含退出當前範圍的指令（如 return, break, throw）。這能避免「箭頭型代碼」（過度巢狀的 if），讓快樂路徑（Happy Path）保持在最外層。 關鍵語法：guard condition else { return } 2. 範例解析 # 文件原始碼：\nfunc greet(person: [String: String]) { guard let name = person[\u0026#34;name\u0026#34;] else { return // 條件不符，必須退出 } // name 在這裡可以直接使用，不需要在 else 區塊內 print(\u0026#34;Hello \\(name)!\u0026#34;) guard let location = person[\u0026#34;location\u0026#34;] else { print(\u0026#34;I hope the weather is nice near you.\u0026#34;) return } print(\u0026#34;I hope the weather is nice in \\(location).\u0026#34;) } 邏輯解說：\n檢查 person[\u0026quot;name\u0026quot;] 是否有值。 如果沒值，進入 else 並返回。 如果有值，解包後的 name 變數可以在 guard 語句之後的代碼中直接使用（這是與 if let 最大的不同）。 3. C# 開發者視角 # 概念對應：C# 沒有 guard 關鍵字。通常使用「反向 if」模式（Guard Clauses pattern）。\nC# 對照程式碼：\nvoid Greet(Dictionary\u0026lt;string, string\u0026gt; person) { if (!person.TryGetValue(\u0026#34;name\u0026#34;, out var name)) { return; } // C# out 變數洩漏到外部範圍，類似 guard 的效果 Console.WriteLine($\u0026#34;Hello {name}!\u0026#34;); } 關鍵差異分析：\n語法面：Swift 的 guard 強制要求 else 區塊必須退出，這在編譯時期就能保證安全性。C# 只是依賴開發者的編碼習慣。 範圍：guard let 綁定的變數作用域是 guard 語句所在的整個區塊（直到結尾），這讓代碼閱讀起來非常流暢。 延遲執行 (Defer) # 1. 核心觀念 # 概念解說：defer 區塊中的代碼會在「當前範圍（Scope）結束前」執行，無論是因為成功執行完畢、return 返回還是拋出錯誤。通常用於資源清理（如關閉檔案、釋放鎖）。 關鍵語法：defer { ... } 2. 範例解析 # 文件原始碼：\nvar score = 1 if score \u0026lt; 10 { defer { print(score) } score += 5 } // Prints \u0026#34;6\u0026#34; 邏輯解說：\n進入 if。 宣告 defer，這裡的 print 被推入堆疊，等待離開範圍時執行。 執行 score += 5，score 變為 6。 準備離開 if 範圍，執行 defer 區塊，印出 6。 3. C# 開發者視角 # 概念對應：類似 C# 的 try-finally 區塊或 using 語句（IDisposable）。\nC# 對照程式碼：\n// C# 使用 try-finally 模擬 { try { score += 5; } finally { Console.WriteLine(score); } } // 或使用 using (若涉及資源釋放) using (var resource = new Resource()) { // code } // Dispose called here 關鍵差異分析：\n靈活性：defer 不需要物件實作介面，也不需要層層包裹的 try-finally。你可以隨時隨地在代碼中間插入一個 defer 來處理清理工作，且多個 defer 會以 LIFO (後進先出) 的順序執行。 API 可用性檢查 (Checking API Availability) # 1. 核心觀念 # 概念解說：由於 iOS/macOS 更新頻繁，Swift 的 #available 是編譯期與執行期協作的機制。 關鍵語法：#available, #unavailable 2. 範例解析 # 文件原始碼：\nif #available(iOS 10, macOS 10.12, *) { // 使用新 API } else { // 使用舊 API } 邏輯解說：* 代表除了前面列出的平台外，其他平台的最低部署目標。編譯器會根據這個判斷，允許你在 if 區塊內使用較新的 API。\n3. C# 開發者視角 # 概念對應：C# 的 OperatingSystem 類別檢查 (Runtime) 或 #if 預處理器指令 (Compile time)。\nC# 對照程式碼：\n// C# Runtime Check (類似) if (OperatingSystem.IsIOSVersionAtLeast(10)) { // Call new API } 關鍵差異分析：\n行為面：Swift 的 #available 與編譯器深度整合。如果你在 #available 區塊外呼叫了新版 API，Swift 編譯器會直接報錯，強迫你加上檢查。C# 的檢查通常是 Runtime 的，編譯器不一定會阻止你在舊系統呼叫新方法（除非使用特定的 Analyzer）。 ","date":"2026.01.26","externalUrl":null,"permalink":"/dev/swift/from-csharp-to-swift/control-flosw/","section":"Devs","summary":"","title":"[從C#到Swift] 05. Control Flow","type":"dev"},{"content":" 從 C# 視角學習 Swift Swift : Collection Types\n集合類型的可變性 (Mutability of Collections) # 1. 核心觀念 # 概念解說：在 Swift 中，集合（Arrays, Sets, Dictionaries）的可變性完全取決於它們是被宣告為變數（var）還是常數（let）。這與集合本身的類型定義無關，而是由宣告方式決定。 關鍵語法：var (Mutable), let (Immutable) 官方提示： 建立不可變的集合（Immutable collections）是一個好的實踐習慣。這不僅讓程式邏輯更清晰，Swift 編譯器也能針對不可變集合進行效能最佳化。\n2. 範例解析 # 文件原始碼：\n// 如果宣告為 var，集合可以在創建後被修改（新增、刪除、變更項目） var mutableArray = [1, 2, 3] mutableArray.append(4) // 如果宣告為 let，集合的大小和內容都不能改變 let immutableArray = [1, 2, 3] // immutableArray.append(4) // 這行會報錯 邏輯解說：這段程式碼展示了 var 賦予了集合修改內容的能力，而 let 則完全鎖定了集合的內容與長度。\n3. C# 開發者視角 # 概念對應：C# 的 readonly 關鍵字與 Swift 的 let 行為有本質上的不同。\nC# 對照程式碼：\n// C# public class CollectionExample { // 即使是 readonly，List 的內容依然可以被修改 public readonly List\u0026lt;int\u0026gt; numbers = new List\u0026lt;int\u0026gt; { 1, 2, 3 }; public void Modify() { numbers.Add(4); // 在 C# 這是合法的！readonly 只保護 reference 不被重新指派 } } 關鍵差異分析：\n語法面：Swift 的 let 宣告集合時，是真正意義上的「完全不可變」（Deep Immutability）。 行為面：這是因為 Swift 的集合類型是 Struct (Value Type)，而 C# 的集合是 Class (Reference Type)。在 Swift 中，當你把 Array 指派給 let，代表這個 Value Type 的實體完全不能被更動；而在 C# 中，readonly List 僅代表你不能將變數指向另一個 List 物件，但原本 List 內部的資料是可以被修改的。若要在 C# 達到 Swift let 的效果，通常需要使用 ImmutableList\u0026lt;T\u0026gt; 或 ReadOnlyCollection\u0026lt;T\u0026gt;。 陣列 (Arrays) # 1. 核心觀念 # 概念解說：Array 是有序的清單，允許儲存重複的值。Swift 的 Array 是一個泛型集合。 關鍵語法：[Element], Array\u0026lt;Element\u0026gt;, append, +=, Subscript syntax [] 官方提示： Swift 的 Array 類型與 Foundation 的 NSArray 類別有橋接（Bridged）關係。\n2. 範例解析 # 文件原始碼：\n// 簡寫語法與初始化 var shoppingList: [String] = [\u0026#34;Eggs\u0026#34;, \u0026#34;Milk\u0026#34;] // 使用 append 新增 shoppingList.append(\u0026#34;Flour\u0026#34;) // 使用 += 連接陣列 shoppingList += [\u0026#34;Baking Powder\u0026#34;, \u0026#34;Chocolate Spread\u0026#34;, \u0026#34;Cheese\u0026#34;, \u0026#34;Butter\u0026#34;] // 使用 Range Subscript 修改範圍內的值 shoppingList[4...6] = [\u0026#34;Bananas\u0026#34;, \u0026#34;Apples\u0026#34;] // 把 index 4 到 6 的三個元素替換成兩個新元素 邏輯解說：\nSwift 偏好使用 [Type] 的簡寫語法。 += 運算子可以用來串接陣列，非常直觀。 最強大的是 Range Subscript，可以直接替換陣列中的一段範圍，且替換的新內容長度不一定要等於原本範圍的長度（如範例中用 2 個元素替換了 3 個元素）。 3. C# 開發者視角 # 概念對應：Swift 的 Array 對應到 C# 的 List\u0026lt;T\u0026gt;，而不是 C# 的原始陣列 T[]。\nC# 對照程式碼：\n// C# var shoppingList = new List\u0026lt;string\u0026gt; { \u0026#34;Eggs\u0026#34;, \u0026#34;Milk\u0026#34; }; shoppingList.Add(\u0026#34;Flour\u0026#34;); shoppingList.AddRange(new [] { \u0026#34;Baking Powder\u0026#34;, \u0026#34;Chocolate Spread\u0026#34; }); // C# List 沒有原生的 Range Assignment 語法，通常需要 RemoveRange + InsertRange shoppingList.RemoveRange(4, 3); shoppingList.InsertRange(4, new [] { \u0026#34;Bananas\u0026#34;, \u0026#34;Apples\u0026#34; }); 關鍵差異分析：\n語法面：Swift 的 += 用於陣列串接比 C# 的 AddRange 更簡潔。Swift 的 Range Subscript ([4...6] = ...) 是 C# 開發者會非常羨慕的功能。 行為面：這是最大的陷阱。Swift 的 Array 是 Value Type，C# 的 List\u0026lt;T\u0026gt; 是 Reference Type。 在 Swift：var a = [1]; var b = a; b.append(2); -\u0026gt; a 還是 [1]，只有 b 變了（Copy-on-Write 機制）。 在 C#：var a = new List\u0026lt;int\u0026gt;{1}; var b = a; b.Add(2); -\u0026gt; a 也會變成 [1, 2]，因為它們指向同一個物件。 集合 (Sets) # 1. 核心觀念 # 概念解說：Set 是無序且元素唯一的集合。存入 Set 的類型必須遵循 Hashable 協定，以便計算雜湊值來確認唯一性。 關鍵語法：Set\u0026lt;Element\u0026gt;, insert, intersection, union, symmetricDifference 2. 範例解析 # 文件原始碼：\nvar favoriteGenres: Set\u0026lt;String\u0026gt; = [\u0026#34;Rock\u0026#34;, \u0026#34;Classical\u0026#34;, \u0026#34;Hip hop\u0026#34;] // 集合運算 let oddDigits: Set\u0026lt;Int\u0026gt; = [1, 3, 5, 7, 9] let evenDigits: Set\u0026lt;Int\u0026gt; = [0, 2, 4, 6, 8] // 交集 oddDigits.intersection(evenDigits).sorted() // [] // 聯集 oddDigits.union(evenDigits).sorted() // [0, 1, ..., 9] 邏輯解說：Swift 將集合運算（交集、聯集、差集）作為 Set 的核心方法直接提供，並且語法非常貼近數學定義。\n3. C# 開發者視角 # 概念對應：對應 C# 的 HashSet\u0026lt;T\u0026gt;。\nC# 對照程式碼：\n// C# var favoriteGenres = new HashSet\u0026lt;string\u0026gt; { \u0026#34;Rock\u0026#34;, \u0026#34;Classical\u0026#34;, \u0026#34;Hip hop\u0026#34; }; var oddDigits = new HashSet\u0026lt;int\u0026gt; { 1, 3, 5, 7, 9 }; var evenDigits = new HashSet\u0026lt;int\u0026gt; { 0, 2, 4, 6, 8 }; // C# 的 HashSet 會直接修改自身 (UnionWith, IntersectWith) // 若要產生新集合需使用 LINQ 或複製建構子 var union = new HashSet\u0026lt;int\u0026gt;(oddDigits); union.UnionWith(evenDigits); 關鍵差異分析：\n語法面：Swift 的 Set 初始化時沒有簡寫語法（如 [Type] 之於 Array），必須寫 Set\u0026lt;Type\u0026gt;，但可以用 Array Literal [] 來賦值。 行為面：Swift 的集合運算方法（如 union）通常會返回一個新的 Set（Functional style），而 C# 的 HashSet 方法（如 UnionWith）通常是 void 並修改當前實例（Imperative style）。若要在 Swift 中修改自身，需使用 formUnion 等帶有 form 前綴的方法。 字典 (Dictionaries) # 1. 核心觀念 # 概念解說：儲存 Key-Value 對應關係的無序集合。Key 必須是 Hashable。 關鍵語法：[Key: Value], updateValue, removeValue, Subscript key access 官方提示： 使用 Subscript 語法存取字典時，回傳的是一個 Optional 值，因為該 Key 可能不存在。\n2. 範例解析 # 文件原始碼：\nvar airports: [String: String] = [\u0026#34;YYZ\u0026#34;: \u0026#34;Toronto Pearson\u0026#34;, \u0026#34;DUB\u0026#34;: \u0026#34;Dublin\u0026#34;] // 新增或修改 airports[\u0026#34;LHR\u0026#34;] = \u0026#34;London\u0026#34; // 使用 updateValue 可以取得舊值 if let oldValue = airports.updateValue(\u0026#34;Dublin Airport\u0026#34;, forKey: \u0026#34;DUB\u0026#34;) { print(\u0026#34;Old value was \\(oldValue)\u0026#34;) } // 存取值（回傳 Optional） if let airportName = airports[\u0026#34;DUB\u0026#34;] { print(\u0026#34;Airport is \\(airportName)\u0026#34;) } else { print(\u0026#34;Not found\u0026#34;) } // 移除 airports[\u0026#34;APL\u0026#34;] = nil // 設為 nil 即移除 邏輯解說：\n[Key: Value] 是標準簡寫。 updateValue 很有用，它在更新同時會回傳「更新前的值」，適合用來做 Log 或邏輯判斷。 將某個 Key 的值設為 nil，等同於從字典中刪除該 Key。 3. C# 開發者視角 # 概念對應：對應 C# 的 Dictionary\u0026lt;TKey, TValue\u0026gt;。\nC# 對照程式碼：\n// C# var airports = new Dictionary\u0026lt;string, string\u0026gt; { { \u0026#34;YYZ\u0026#34;, \u0026#34;Toronto Pearson\u0026#34; }, { \u0026#34;DUB\u0026#34;, \u0026#34;Dublin\u0026#34; } }; // 存取值 - C# 的索引器若 Key 不存在會拋出 Exception // string name = airports[\u0026#34;INVALID\u0026#34;]; // Throws KeyNotFoundException // 安全存取方式 if (airports.TryGetValue(\u0026#34;DUB\u0026#34;, out string airportName)) { Console.WriteLine($\u0026#34;Airport is {airportName}\u0026#34;); } // 移除 airports.Remove(\u0026#34;APL\u0026#34;); // 不能賦值 null 來移除 關鍵差異分析：\n語法面： Swift 的索引存取 dict[key] 永遠回傳 Optional，這迫使開發者處理 Key 不存在的情況（更安全）。 C# 的索引存取 dict[key] 假設 Key 存在，否則拋出例外。C# 開發者必須習慣使用 TryGetValue 或是 Swift 的 Optional Binding (if let)。 行為面： 在 Swift 中，dict[\u0026quot;key\u0026quot;] = nil 是刪除操作。 在 C# 中，如果 Value Type 是 Reference Type，dict[\u0026quot;key\u0026quot;] = null 只是把該 Value 設為 null，Key 依然存在於字典中。這是非常容易混淆的點。 迭代 (Iteration)：Swift 迭代字典時拿到的是 Tuple (key, value)，非常方便解構；C# 拿到的是 KeyValuePair\u0026lt;TKey, TValue\u0026gt; 物件，需存取 .Key 和 .Value 屬性。 // Swift 迭代 for (code, name) in airports { print(\u0026#34;\\(code): \\(name)\u0026#34;) } // C# 迭代 foreach (var kvp in airports) { Console.WriteLine($\u0026#34;{kvp.Key}: {kvp.Value}\u0026#34;); } ","date":"2026.01.25","externalUrl":null,"permalink":"/dev/swift/from-csharp-to-swift/collection-types/","section":"Devs","summary":"","title":"[從C#到Swift] 04. Collection Types","type":"dev"},{"content":" 從 C# 視角學習 Swift Swift : Strings and Characters\n字串字面量與初始化 (String Literals \u0026amp; Initialization) # 1. 核心觀念 # 概念解說：Swift 的 String 類型是一個快速且兼容 Unicode 的文字處理工具。它的語法設計輕量，類似 C 語言，但底層實作非常現代化。與 Objective-C 的 NSString 不同，Swift 的 String 是一個 struct（Value Type），而非 class。 關鍵語法：\u0026quot;\u0026quot; (雙引號), \u0026quot;\u0026quot;\u0026quot; (多行字串), String() (初始化), isEmpty 官方提示： Swift 的 String 類型與 Foundation 的 NSString 類別是橋接的 (Bridged)。如果你導入了 Foundation，你可以在 String 上直接呼叫 NSString 的方法而無需轉型。\n2. 範例解析 # 文件原始碼：\nlet someString = \u0026#34;Some string literal value\u0026#34; // 多行字串 (Multiline String Literals) let quotation = \u0026#34;\u0026#34;\u0026#34; The White Rabbit put on his spectacles. \u0026#34;Where shall I begin, please your Majesty?\u0026#34; he asked. \u0026#34;Begin at the beginning,\u0026#34; the King said gravely, \u0026#34;and go on till you come to the end; then stop.\u0026#34; \u0026#34;\u0026#34;\u0026#34; // 初始化空字串 var emptyString = \u0026#34;\u0026#34; // 空字串字面量 var anotherEmptyString = String() // 初始化語法 if emptyString.isEmpty { print(\u0026#34;Nothing to see here\u0026#34;) } 邏輯解說： Swift 使用雙引號定義單行字串。多行字串則使用三個雙引號 \u0026quot;\u0026quot;\u0026quot; 包裹，且起始與結束的引號必須獨立成行。縮排規則由結束的 \u0026quot;\u0026quot;\u0026quot; 位置決定，這讓程式碼排版更加整潔。isEmpty 屬性是用來檢查字串是否為空的高效方式。\n3. C# 開發者視角 # 概念對應：C# 的 string 也使用雙引號。Swift 的多行字串類似 C# 11 引入的 Raw String Literals (\u0026quot;\u0026quot;\u0026quot;...\u0026quot;\u0026quot;\u0026quot;) 或較舊的 Verbatim String (@\u0026quot;...\u0026quot;)。\nC# 對照程式碼：\n// C# string someString = \u0026#34;Some string literal value\u0026#34;; // C# 11 Raw String Literal (類似 Swift 的多行處理) string quotation = \u0026#34;\u0026#34;\u0026#34; The White Rabbit put on his spectacles. \u0026#34;Begin at the beginning,\u0026#34; the King said. \u0026#34;\u0026#34;\u0026#34;; // 空字串檢查 string emptyString = \u0026#34;\u0026#34;; bool isEmpty = string.IsNullOrEmpty(emptyString); // 或 emptyString.Length == 0 關鍵差異分析：\n語法面：Swift 的多行字串縮排處理非常智慧，它會自動忽略各行前方與結尾 \u0026quot;\u0026quot;\u0026quot; 對齊的空白，這在 C# 中直到最近的版本（C# 11）才透過 Raw String Literals 完美支援。 行為面：Swift 推薦使用 isEmpty 屬性，而 C# 開發者習慣用 string.IsNullOrEmpty() 或檢查 Length == 0。 字串的可變性與數值型別 (Mutability \u0026amp; Value Types) # 1. 核心觀念 # 概念解說：這是 Swift 與許多語言最大的不同點之一。Swift 的 String 是 Value Type (實值型別)，而非 Reference Type。此外，字串是否可變（Mutable）完全取決於它是被宣告為變數 (var) 還是常數 (let)。 關鍵語法：var (可變), let (不可變), struct (Value Type) 2. 範例解析 # 文件原始碼：\nvar variableString = \u0026#34;Horse\u0026#34; variableString += \u0026#34; and carriage\u0026#34; // variableString 現在是 \u0026#34;Horse and carriage\u0026#34; let constantString = \u0026#34;Highlander\u0026#34; // constantString += \u0026#34; and another Highlander\u0026#34; // 編譯錯誤：常數字串無法被修改 邏輯解說： 當 String 被傳遞給函式或賦值給另一個變數時，實際上會發生複製（Copy）。雖然 Swift 編譯器會進行 copy-on-write 優化（即只有在真正修改內容時才複製），但在語意上，你擁有該字串的獨立副本。\n3. C# 開發者視角 # 概念對應：C# 的 string 是 Reference Type，但它是不可變的 (Immutable)。若要修改字串，C# 通常會產生新的物件或使用 StringBuilder。\nC# 對照程式碼：\n// C# string str = \u0026#34;Horse\u0026#34;; str += \u0026#34; and carriage\u0026#34;; // 實際上創造了一個新的 string 物件並重新指向 // C# 沒有直接對應 let 的常數宣告來禁止重新賦值引發的修改， // 除非使用 const (需編譯時確認) 或 readonly (僅限欄位)。 關鍵差異分析：\n語法面：Swift 用 var 直接支援字串修改（拼接），類似於 C# 的 StringBuilder 的易用版，但語法上像普通字串操作。 行為面：這是最大陷阱。在 C# 中，字串變數存的是參考（Reference）；在 Swift 中，String 是 Struct。 C#: string a = \u0026quot;hi\u0026quot;; string b = a; -\u0026gt; a 和 b 指向堆積區同一塊記憶體。 Swift: var a = \u0026quot;hi\u0026quot;; var b = a; b += \u0026quot;!\u0026quot; -\u0026gt; 修改 b 不會 影響 a，因為賦值發生時產生了拷貝（邏輯上）。 字串擴充與插值 (Concatenation \u0026amp; Interpolation) # 1. 核心觀念 # 概念解說：Swift 提供了直觀的運算子來串接字串，以及強大的字串插值功能，允許在字串中嵌入變數或運算式。 關鍵語法：+, +=, append(), \\(expression) 2. 範例解析 # 文件原始碼：\nlet string1 = \u0026#34;hello\u0026#34; let string2 = \u0026#34; there\u0026#34; var welcome = string1 + string2 var instruction = \u0026#34;look over\u0026#34; instruction += string2 // 字串插值 let multiplier = 3 let message = \u0026#34;\\(multiplier) times 2.5 is \\(Double(multiplier) * 2.5)\u0026#34; // message 為 \u0026#34;3 times 2.5 is 7.5\u0026#34; 邏輯解說： 字串插值使用反斜線加括號 \\(...) 的語法。這比起傳統的格式化字串更直觀且強型別安全。\n3. C# 開發者視角 # 概念對應：相當於 C# 的字串串接與 String Interpolation。\nC# 對照程式碼：\n// C# int multiplier = 3; // C# 使用 $ 字號和大括號 string message = $\u0026#34;{multiplier} times 2.5 is {multiplier * 2.5}\u0026#34;; 關鍵差異分析：\n語法面：Swift 使用 \\()，C# 使用 {} (配合 $)。 行為面：兩者在編譯時都會轉化為高效的字串建構呼叫。注意 Swift 的插值括號內不能包含未轉義的反斜線或換行符號。 Unicode 與字元計數 (Unicode, Characters \u0026amp; Counting) # 1. 核心觀念 # 概念解說：Swift 的 String 是基於 Unicode Scalar Values 建構的。最特別的是它對 Extended Grapheme Clusters (擴展字形集) 的支援。一個「人類可讀的字元」（如 é 或 🇹🇼）可能由一個或多個 Unicode 純量組成，但在 Swift 中它們都被視為單一個 Character。 關鍵語法：Character, count 屬性, \\u{n} 2. 範例解析 # 文件原始碼：\nlet eAcute: Character = \u0026#34;\\u{E9}\u0026#34; // é let combinedEAcute: Character = \u0026#34;\\u{65}\\u{301}\u0026#34; // e 後面接撇號 // 兩者在 Swift 中都被視為同一個字元 var word = \u0026#34;cafe\u0026#34; word += \u0026#34;\\u{301}\u0026#34; // 加上撇號 print(\u0026#34;the number of characters in \\(word) is \\(word.count)\u0026#34;) // 輸出 \u0026#34;the number of characters in café is 4\u0026#34; (雖然加了東西，但視覺上還是一個字，長度不變) 邏輯解說： 這是 Swift 字串處理最強大也最複雜的地方。count 屬性回傳的是「人類看起來有幾個字」，而不是底層用了幾個 Byte 或幾個 16-bit 單位。因為需要計算字形集邊界，存取 count 可能需要遍歷整個字串，並非 O(1) 操作。\n3. C# 開發者視角 # 概念對應：C# 的 char 是 16-bit (UTF-16 code unit)。C# 的 string.Length 回傳的是 16-bit 單位的數量，而非真實字元數。\nC# 對照程式碼：\n// C# string word = \u0026#34;cafe\u0026#34;; word += \u0026#34;\\u0301\u0026#34;; // 加上結合重音符 Console.WriteLine(word.Length); // 輸出 5 (因為 e 和 重音符 是兩個分開的 char) 關鍵差異分析：\n語法面：無特別差異，但 Swift 的 Unicode 轉義是用 \\u{...} 可容納不同長度 Hex，C# 是 \\uXXXX 或 \\UXXXXXXXX。 行為面：極度重要！ Emoji 處理：一個 Emoji (如 🐶) 在 C# string.Length 通常是 2 (Surrogate Pair)；在 Swift .count 是 1。 效能：C# 的 Length 是 O(1)；Swift 的 count 需遍歷字串，是 O(n)。若在迴圈中頻繁呼叫 count 需注意效能。 存取與修改字串 (Accessing and Modifying) # 1. 核心觀念 # 概念解說：由於上述的 Unicode 複雜性（每個字元長度不等），Swift 不允許 使用整數索引（例如 str[0]）來存取字串。你必須使用 String.Index。 關鍵語法：startIndex, endIndex, index(before:), index(after:), index(_:offsetBy:) 2. 範例解析 # 文件原始碼：\nlet greeting = \u0026#34;Guten Tag!\u0026#34; // 存取第一個字元 greeting[greeting.startIndex] // G // 存取特定位置 (例如第 7 個字元) let index = greeting.index(greeting.startIndex, offsetBy: 7) greeting[index] // a // 插入 var welcome = \u0026#34;hello\u0026#34; welcome.insert(\u0026#34;!\u0026#34;, at: welcome.endIndex) // 移除 welcome.remove(at: welcome.index(before: welcome.endIndex)) 邏輯解說： 你不能直接寫 greeting[7]，必須先計算出代表「第 7 個字形集」的 String.Index 物件，再用它來取值。這是為了防止隨機存取切斷了多位元組的字元（如切斷 Emoji 的一半）。\n3. C# 開發者視角 # 概念對應：C# 允許整數索引 str[i]，但這存取的是 char (UTF-16 code unit)，不一定是完整字元。\nC# 對照程式碼：\n// C# string greeting = \u0026#34;Guten Tag!\u0026#34;; char c = greeting[7]; // 直接使用整數索引 \u0026#39;a\u0026#39; // 插入與移除 (C# string 不可變，需產生新字串) string welcome = \u0026#34;hello\u0026#34;; welcome = welcome.Insert(welcome.Length, \u0026#34;!\u0026#34;); welcome = welcome.Remove(welcome.Length - 1); 關鍵差異分析：\n語法面：Swift 的索引語法非常冗長（index(_:offsetBy:)）。這是為了強迫開發者意識到字串遍歷的成本。 行為面：在 C# 中你習慣 for (int i=0; i\u0026lt;str.Length; i++)，但在 Swift 中應盡量使用 for char in string 或高階函數。如果你需要頻繁隨機存取，建議將 String 轉為 Array (Array(str))，但要注意這會失去部分 Unicode 處理特性且增加記憶體消耗。 子字串 (Substrings) # 1. 核心觀念 # 概念解說：當你對 Swift 字串進行切片（Slicing）時，回傳的型別不是 String，而是 Substring。Substring 會與原始字串共用記憶體，這是一種效能優化。 關鍵語法：prefix(_:), [range], Substring 型別, String(substring) 2. 範例解析 # 文件原始碼：\nlet greeting = \u0026#34;Hello, world!\u0026#34; let index = greeting.firstIndex(of: \u0026#34;,\u0026#34;) ?? greeting.endIndex let beginning = greeting[..\u0026lt;index] // beginning 的型別是 Substring，它重用了 greeting 的記憶體 // 若要長期儲存，需轉回 String let newString = String(beginning) 邏輯解說： Substring 雖然高效，但不適合長期持有。因為只要 Substring 還在，原始的完整 String 記憶體就無法被釋放。\n3. C# 開發者視角 # 概念對應：C# 的 Substring() 方法傳統上會分配新的記憶體並複製字串。但在較新的 C# (Core/Standard) 中，Span\u0026lt;char\u0026gt; 或 ReadOnlySpan\u0026lt;char\u0026gt; 的概念與 Swift 的 Substring 非常相似——它們都是原本記憶體的「視圖 (View)」。\nC# 對照程式碼：\n// C# (傳統) string greeting = \u0026#34;Hello, world!\u0026#34;; int idx = greeting.IndexOf(\u0026#39;,\u0026#39;); string beginning = greeting.Substring(0, idx); // 分配新記憶體 // C# (高效能 Span) ReadOnlySpan\u0026lt;char\u0026gt; span = greeting.AsSpan(); ReadOnlySpan\u0026lt;char\u0026gt; slice = span.Slice(0, idx); // 零配置，類似 Swift Substring 關鍵差異分析：\n行為面：Swift 強制區分 String 和 Substring 型別，防止你無意間長期持有大字串的引用。C# 的 Substring 直接回傳 string (發生複製)，除非你顯式使用 Span。 字串比較 (Comparing Strings) # 1. 核心觀念 # 概念解說：Swift 的字串比較是用「標準等價 (Canonical Equivalence)」進行的。這意味著如果兩個字串顯示出來一樣，它們就相等，即使底層的 Unicode 組成不同。 關鍵語法：==, !=, hasPrefix(), hasSuffix() 2. 範例解析 # 文件原始碼：\n// \u0026#34;é\u0026#34; (單一純量) vs \u0026#34;e\u0026#34; + \u0026#34;́\u0026#34; (組合純量) let eAcuteQuestion = \u0026#34;Voulez-vous un caf\\u{E9}?\u0026#34; let combinedEAcuteQuestion = \u0026#34;Voulez-vous un caf\\u{65}\\u{301}?\u0026#34; if eAcuteQuestion == combinedEAcuteQuestion { print(\u0026#34;These two strings are considered equal\u0026#34;) } 官方提示：\nSwift 的字串與字元比較不是 Locale-sensitive（與語系環境無關）的。\n3. C# 開發者視角 # 概念對應：C# 的 == 是基於 UTF-16 code unit 的內容比較（ordinal），不做 Unicode 正規化。\nC# 對照程式碼：\n// C# string s1 = \u0026#34;\\u00E9\u0026#34;; string s2 = \u0026#34;e\\u0301\u0026#34;; Console.WriteLine(s1 == s2); // False! 因為底層 char 序列不同 // 若要達到 Swift 的效果，需正規化 Console.WriteLine(s1.Normalize() == s2.Normalize()); // True 關鍵差異分析：\n行為面：這是另一個潛在 Bug 來源。Swift 的 == 比較聰明（但也比較慢），會自動處理 Unicode 正規化。C# 的 == 比較快，但嚴格比較 char 序列。若需在 C# 做類似比較，需手動呼叫 String.Normalize()。 ","date":"2026.01.24","externalUrl":null,"permalink":"/dev/swift/from-csharp-to-swift/strings-and-characters/","section":"Devs","summary":"","title":"[從C#到Swift] 03. Strings and Characters","type":"dev"},{"content":" 從 C# 視角學習 Swift Swift : Basic Operators\n術語與基礎 (Terminology) # 1. 核心觀念 # 概念解說：Swift 的運算子分為一元 (Unary)、二元 (Binary) 和三元 (Ternary)。這些概念與大多數 C 語言家族的成員相同。運算子操作的對象稱為運算元 (Operands)。 關鍵語法：Unary (-a), Binary (a + b), Ternary (a ? b : c) 官方提示：無 2. 範例解析 # 文件原始碼：\nlet i = 1 + 2 if enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan { ... } 邏輯解說： + 是二元運算子，將 1 與 2 相加。\u0026amp;\u0026amp; 是邏輯 AND 運算子，用於結合兩個布林值。\n3. C# 開發者視角 # 概念對應：C# 中同樣擁有這三類運算子，基礎分類完全一致。\nC# 對照程式碼：\nint i = 1 + 2; if (enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan) { ... } 關鍵差異分析：\n語法面：基本一致。 行為面：無顯著差異。 賦值運算子 (Assignment Operator) # 1. 核心觀念 # 概念解說：使用 = 將右邊的值初始化或更新給左邊的變數。Swift 的賦值運算子有一個重要的安全特性：它不會回傳值。 關鍵語法：= 官方提示： 如果賦值運算子的右側是擁有多個值的 Tuple，它的元素可以被一次分解為多個常數或變數。\n2. 範例解析 # 文件原始碼：\nlet b = 10 var a = 5 a = b // a 現在等於 10 var (x, y) = (1, 2) // x 等於 1, y 等於 2 if x = y { // 這是無效的，因為 x = y 不會回傳值 } 邏輯解說： 這段程式碼展示了基本的賦值以及 Tuple 的解構賦值。最重要的是最後一段，Swift 編譯器會報錯，防止開發者原本想寫 == (比較) 卻誤寫成 = (賦值) 的常見錯誤。\n3. C# 開發者視角 # 概念對應：對應 C# 的 = 賦值。但 C# 的賦值表達式是有回傳值的（回傳被賦予的那個值）。\nC# 對照程式碼：\nint b = 10; int a = 5; a = b; // C# 7.0+ 支援 Tuple 解構 (int x, int y) = (1, 2); // C# 中這在某些情況下是合法的（雖然編譯器可能會警告，或者用於 while 迴圈中） // if (x = y) { ... } // 如果 x, y 是 bool 則編譯通過 關鍵差異分析：\n語法面：Tuple 解構語法 let (x, y) = (1, 2) 非常簡潔，類似 C# 的 (var x, var y) = (1, 2)。 行為面：陷阱注意！在 C# 中，a = b 表達式的結果是 b 的值，這允許連續賦值 a = b = c。但在 Swift 中，賦值不回傳值，因此 a = b = c 在 Swift 是不合法的，且 if x = y 會直接導致編譯錯誤，這是一個防止 Bug 的設計。 算術運算子 (Arithmetic Operators) # 1. 核心觀念 # 概念解說：Swift 支援標準的四則運算 (+, -, *, /)。與 C/C++ 不同的是，Swift 預設不允許值溢位 (Overflow)，如果計算結果超出型別範圍，程式會報錯（Crash），而非默默截斷。 關鍵語法：+, -, *, /, String concatenation 官方提示： 與 C 和 Objective-C 的算術運算子不同，Swift 的算術運算子預設不允許值溢位。你可以透過 Swift 的溢位運算子（如 \u0026amp;+）來啟用溢位行為。\n2. 範例解析 # 文件原始碼：\n1 + 2 // 等於 3 5 - 3 // 等於 2 2 * 3 // 等於 6 10.0 / 2.5 // 等於 4.0 \u0026#34;hello, \u0026#34; + \u0026#34;world\u0026#34; // 等於 \u0026#34;hello, world\u0026#34; 邏輯解說： 展示了整數與浮點數的基本運算，以及 + 號可用於字串串接。\n3. C# 開發者視角 # 概念對應：對應 C# 的算術運算子。\nC# 對照程式碼：\nint sum = 1 + 2; double div = 10.0 / 2.5; string str = \u0026#34;hello, \u0026#34; + \u0026#34;world\u0026#34;; 關鍵差異分析：\n語法面：完全一致。 行為面：記憶體管理與安全。C# 的 int 運算預設在 unchecked 環境下會發生溢位（Wrap around），除非你顯式放在 checked 區塊中。Swift 則是預設就等同於 checked，溢位會導致 Runtime Error。若要像 C# 預設那樣允許溢位，Swift 需改用 \u0026amp;+, \u0026amp;-, \u0026amp;* 等溢位運算子。 餘數運算子 (Remainder Operator) # 1. 核心觀念 # 概念解說：計算 a % b，算出多少個 b 能塞進 a，並回傳剩下的部分。 關鍵語法：% 官方提示： 餘數運算子 (%) 在其他語言中也被稱為模數運算子 (modulo operator)。然而，嚴格來說，Swift 對負數的行為是「餘數」而非「模數」。\n2. 範例解析 # 文件原始碼：\n9 % 4 // 等於 1 -9 % 4 // 等於 -1 邏輯解說： 9 = (4 x 2) + 1，故餘數為 1。 -9 = (4 x -2) + (-1)，故餘數為 -1。 Swift 的規則是 a % b 的正負號取決於 a。\n3. C# 開發者視角 # 概念對應：C# 的 % 運算子也是 Remainder Operator，而非數學上的 Modulo。\nC# 對照程式碼：\nint r1 = 9 % 4; // 1 int r2 = -9 % 4; // -1 關鍵差異分析：\n行為面：Swift 與 C# 在這點上行為一致，對於負數的處理都是回傳餘數（結果的正負號跟隨被除數）。 一元運算子 (Unary Minus / Plus Operator) # 1. 核心觀念 # 概念解說：- 用於切換數值的正負號；+ 僅回傳數值本身（通常為了對稱性而存在）。 關鍵語法：-, + 2. 範例解析 # 文件原始碼：\nlet three = 3 let minusThree = -three // -3 let plusThree = -minusThree // 3 let minusSix = -6 let alsoMinusSix = +minusSix // -6 邏輯解說： 直接操作數值的正負符號。\n3. C# 開發者視角 # 概念對應：完全對應 C# 的一元運算子。\nC# 對照程式碼：\nint three = 3; int minusThree = -three; 關鍵差異分析：\n行為面：無差異。 複合賦值運算子 (Compound Assignment Operators) # 1. 核心觀念 # 概念解說：將運算與賦值結合，如 +=。 關鍵語法：+=, -=, *=, /= 官方提示： 複合賦值運算子不回傳值。例如，你不能寫 let b = a += 2。\n2. 範例解析 # 文件原始碼：\nvar a = 1 a += 2 // a 現在是 3 邏輯解說： a += 2 等同於 a = a + 2。\n3. C# 開發者視角 # 概念對應：C# 也有 +=。\nC# 對照程式碼：\nint a = 1; a += 2; // int b = (a += 2); // 在 C# 這是合法的！ 關鍵差異分析：\n行為面：再次強調，Swift 的 += 沒有回傳值，而 C# 的 += 會回傳運算後的結果。所以在 Swift 不能像 C# 那樣把它當作表達式的一部分來使用。 比較運算子 (Comparison Operators) # 1. 核心觀念 # 概念解說：用於比較兩個值，回傳 Bool (true 或 false)。Swift 支援 Tuple 的比較（最多由小於 7 個元素組成的 Tuple）。 關鍵語法：==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=, ===, !== 官方提示： Swift 還提供了兩個恆等運算子（=== 和 !==），用於測試兩個物件參考是否指向同一個物件實例。 Swift 標準函式庫包含少於 7 個元素的 Tuple 比較運算子。\n2. 範例解析 # 文件原始碼：\n1 == 1 // true (1, \u0026#34;zebra\u0026#34;) \u0026lt; (2, \u0026#34;apple\u0026#34;) // true (因為 1 \u0026lt; 2) (3, \u0026#34;apple\u0026#34;) \u0026lt; (3, \u0026#34;bird\u0026#34;) // true (3 等於 3，且 apple 小於 bird) 邏輯解說： Tuple 的比較是「由左至右」逐一比較。一旦發現某個元素不相等，該元素的比較結果就決定了整個 Tuple 的比較結果。\n3. C# 開發者視角 # 概念對應：C# 的比較運算子。=== 對應 C# 的 Object.ReferenceEquals。\nC# 對照程式碼：\nbool result = 1 == 1; // C# 7.3+ 支援 Tuple `==` 和 `!=`，但 `\u0026lt;` `\u0026gt;` 並不直接支援 Tuple 比較 var t1 = (1, \u0026#34;zebra\u0026#34;); var t2 = (2, \u0026#34;apple\u0026#34;); // bool tupleComp = t1 \u0026lt; t2; // 編譯錯誤，C# Tuple 不直接支援 \u0026lt; 關鍵差異分析：\n語法面：Swift 的 === 用於 Reference Type 的指標比較，語法比 C# 的 Object.ReferenceEquals(a, b) 更簡潔。 行為面：Swift 原生支援 Tuple 的大小比較 (\u0026lt;, \u0026gt;)，C# 的 Tuple (ValueTuple) 目前僅支援 == 與 !=，若要比較大小需呼叫 CompareTo 或自行撰寫比較邏輯。 三元條件運算子 (Ternary Conditional Operator) # 1. 核心觀念 # 概念解說：question ? answer1 : answer2。若 question 為真回傳 answer1，否則回傳 answer2。 關鍵語法：? : 2. 範例解析 # 文件原始碼：\nlet contentHeight = 40 let hasHeader = true let rowHeight = contentHeight + (hasHeader ? 50 : 20) // rowHeight 等於 90 邏輯解說： 這是一種簡潔的 if-else 表達式，適合用於單行賦值。\n3. C# 開發者視角 # 概念對應：完全對應 C# 的 ? : 運算子。\nC# 對照程式碼：\nint contentHeight = 40; bool hasHeader = true; int rowHeight = contentHeight + (hasHeader ? 50 : 20); 關鍵差異分析：\n行為面：無差異。 空值合併運算子 (Nil-Coalescing Operator) # 1. 核心觀念 # 概念解說：a ?? b。如果 Optional a 有值就解包使用，若是 nil 則使用預設值 b。 關鍵語法：?? 官方提示： 如果 a 的值非 nil，則不會評估 b 的值。這稱為短路求值 (short-circuit evaluation)。\n2. 範例解析 # 文件原始碼：\nlet defaultColorName = \u0026#34;red\u0026#34; var userDefinedColorName: String? // 預設為 nil var colorNameToUse = userDefinedColorName ?? defaultColorName // colorNameToUse 被設為 \u0026#34;red\u0026#34; 邏輯解說： 這是處理 Optional 非常優雅的方式，避免了冗長的 if let 或三元運算子。\n3. C# 開發者視角 # 概念對應：對應 C# 的 Null-coalescing operator ??。\nC# 對照程式碼：\nstring defaultColor = \u0026#34;red\u0026#34;; string? userColor = null; string colorToUse = userColor ?? defaultColor; 關鍵差異分析：\n語法面：完全一致。Swift 針對的是 Optional 類型，C# 針對的是 Nullable Reference Types 或 Nullable Value Types。 區間運算子 (Range Operators) # 1. 核心觀念 # 概念解說：Swift 提供特殊的運算子來表達數值範圍。 閉區間 (Closed Range) a...b：包含 a 和 b。 半開區間 (Half-Open Range) a..\u0026lt;b：包含 a 但不包含 b。 單邊區間 (One-Sided Ranges) a... 或 ...b：延伸到盡頭。 關鍵語法：..., ..\u0026lt; 2. 範例解析 # 文件原始碼：\n// 閉區間 for index in 1...5 { ... } // 1, 2, 3, 4, 5 // 半開區間 for i in 0..\u0026lt;count { ... } // 0 到 count-1 // 單邊區間 (用於陣列切片) for name in names[2...] { ... } // 從索引 2 到最後 邏輯解說： 閉區間常用於皆需處理的迴圈；半開區間特別適合用於 0-based 的陣列索引遍歷。\n3. C# 開發者視角 # 概念對應：C# 8.0 引入了 Range 語法 ..。\nC# 對照程式碼：\n// C# 的 Range 主要用於索引與切片，較少直接用於 foreach 迴圈 (需配合 Enumerable.Range) sring[] names = { \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34; }; // Swift: names[2...] var slice = names[2..]; // Swift: 1...5 (C# 沒有直接對應的迴圈語法，通常用 for 迴圈) // foreach (var i in 1..5) // C# 不支援這種寫法 foreach (var i in Enumerable.Range(1, 5)) { ... } 關鍵差異分析：\n語法面： Swift 的閉區間是 ...，C# 的 Range 是 ..。 Swift 的半開區間是 ..\u0026lt;，C# 的 .. 本質上就是半開區間 (Exclusive end)。 行為面：Swift 的 Range 是非常核心的型別 (ClosedRange\u0026lt;T\u0026gt;, Range\u0026lt;T\u0026gt;)，可以直接用於 for-in 迴圈、switch 模式比對 (case 1...10:) 以及陣列切片。C# 的 Range (System.Range) 目前主要用於陣列/Span 的切片索引，不能直接丟進 foreach 跑迴圈。 邏輯運算子 (Logical Operators) # 1. 核心觀念 # 概念解說：結合布林邏輯值。 關鍵語法：!a (NOT), a \u0026amp;\u0026amp; b (AND), a || b (OR) 官方提示： Swift 邏輯運算子 \u0026amp;\u0026amp; 和 || 是左相依 (left-associative) 的。\n2. 範例解析 # 文件原始碼：\nif !allowedEntry { ... } if enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan { ... } if hasDoorKey || knowsOverridePassword { ... } 邏輯解說： 支援短路求值（Short-circuit evaluation），即 \u0026amp;\u0026amp; 前者為假則不看後者，|| 前者為真則不看後者。\n3. C# 開發者視角 # 概念對應：完全對應 C# 的邏輯運算子。\nC# 對照程式碼：\nif (!allowedEntry) { ... } if (enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan) { ... } 關鍵差異分析：\n行為面：無差異。兩者都支援短路求值。值得注意的是 Swift 鼓勵使用括號 () 來明確複雜表達式的優先級，這在 C# 中也是好習慣。 ","date":"2026.01.23","externalUrl":null,"permalink":"/dev/swift/from-csharp-to-swift/basic-operators/","section":"Devs","summary":"","title":"[從C#到Swift] 02. Basic Operators","type":"dev"},{"content":" 從 C# 視角學習 Swift Swift : The Basic\n常數與變數 (Constants and Variables) # 1. 核心觀念 # 概念解說：Swift 非常強調安全性，因此在宣告儲存容器時，強制區分「不可變 (Immutable)」與「可變 (Mutable)」。這有助於編譯器優化並防止意外修改數據。 關鍵語法：let (常數), var (變數) 官方提示： 如果你的代碼中儲存的值不會改變，請務必使用 let 關鍵字宣告為常數。只有在需要改變值時才使用變數。\n2. 範例解析 # 文件原始碼：\nlet maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 var environment = \u0026#34;development\u0026#34; let maximumNumberOfLoginAttempts: Int // maximumNumberOfLoginAttempts 目前還沒有值 if environment == \u0026#34;development\u0026#34; { maximumNumberOfLoginAttempts = 100 } else { maximumNumberOfLoginAttempts = 10 } // 現在 maximumNumberOfLoginAttempts 有值了，可以被讀取 邏輯解說： 這段代碼展示了 let 與 var 的基本宣告。值得注意的是，let 宣告的常數不一定要在宣告的那一行立即賦值（如第二段範例），但必須保證在第一次讀取前「被賦值一次且僅一次」。\n3. C# 開發者視角 # 概念對應：\nSwift 的 var 對應 C# 的 var (或明確型別變數)。 Swift 的 let 概念上介於 C# 的 const 與 readonly 之間，但在區域變數的使用上，C# 沒有完全等價的「執行期不可變區域變數」關鍵字 (雖然 C# 的 const 必須是編譯期常數)。 C# 對照程式碼：\n// C# const int MaximumNumberOfLoginAttempts = 10; // 必須在編譯期確認數值 var currentLoginAttempt = 0; // C# 模擬 Swift 的延遲初始化常數 (C# 無法直接對區域變數做唯讀強制檢查) int maxLoginAttempts; var environment = \u0026#34;development\u0026#34;; if (environment == \u0026#34;development\u0026#34;) { maxLoginAttempts = 100; } else { maxLoginAttempts = 10; } // 在 C# 中，maxLoginAttempts 之後仍可被修改，這就是安全性差異 關鍵差異分析：\n語法面：Swift 用 let 和 var 兩個關鍵字統治所有宣告；C# 則常混用 var、const、readonly 和明確型別。 行為面：Swift 的 let 允許「執行期計算 (Runtime evaluation)」，只要保證賦值一次即可。C# 的 const 必須是「編譯期常數 (Compile-time constant)」。這讓 Swift 的 let 比 C# 的 const 更有彈性且常用。 型別標註與推斷 (Type Safety and Inference) # 1. 核心觀念 # 概念解說：Swift 是強型別語言 (Type Safe)。你可以明確告訴編譯器變數是什麼型別 (Type Annotation)，也可以讓編譯器根據初始值自動猜測 (Type Inference)。 關鍵語法：: (冒號後接型別), String, Int, Double 2. 範例解析 # 文件原始碼：\nvar welcomeMessage: String welcomeMessage = \u0026#34;Hello\u0026#34; var x = 0.0, y = 0.0, z = 0.0 // 推斷為 Double let meaningOfLife = 42 // 推斷為 Int let pi = 3.14159 // 推斷為 Double 邏輯解說： 當沒有提供初始值時（如 welcomeMessage），必須明確寫出 : String。若有初始值（如 meaningOfLife），編譯器會自動推斷。\n3. C# 開發者視角 # 概念對應：這與 C# 的型別系統幾乎一致。\nC# 對照程式碼：\n// C# string welcomeMessage; welcomeMessage = \u0026#34;Hello\u0026#34;; var x = 0.0; // 推斷為 double var meaningOfLife = 42; // 推斷為 int 關鍵差異分析：\n語法面：Swift 變數名稱在冒號前，型別在冒號後 (name: Type)；C# 是型別在前 (Type name)。 行為面：兩者的推斷機制 (Swift 的 Type Inference vs C# 的 var) 非常相似。但 Swift 對型別轉換更嚴格（完全不允許隱式轉換，詳見後文）。 數值型別與轉換 (Numeric Types and Conversion) # 1. 核心觀念 # 概念解說：Swift 提供了 Int、UInt、Double、Float 等數值型別。特別注意 Swift 不支援不同數值型別之間的「隱式轉換 (Implicit Conversion)」，即使是將整數放入浮點數變數也必須顯式轉換。 關鍵語法：Int.min, Int.max, Double(...), Int(...) 官方提示： 除非你需要特定大小的整數（如處理外部資料），否則請一律使用 Int。即使在 32 位元平台上，Int 也足夠涵蓋 -20 億到 20 億的範圍。\n2. 範例解析 # 文件原始碼：\nlet twoThousand: UInt16 = 2_000 let one: UInt8 = 1 let twoThousandAndOne = twoThousand + UInt16(one) // 必須手動轉換 let three = 3 let pointOneFourOneFiveNine = 0.14159 let pi = Double(three) + pointOneFourOneFiveNine // 整數轉浮點 邏輯解說： Swift 不允許將 UInt8 直接加到 UInt16 上，也不允許將 Int 與 Double 直接相加。必須使用構造函數（如 UInt16(one)）進行轉換，這其實是建立了一個新數值。\n3. C# 開發者視角 # 概念對應：C# 允許「擴大轉換 (Widening Conversions)」的隱式行為，但 Swift 完全禁止。\nC# 對照程式碼：\n// C# ushort twoThousand = 2000; byte one = 1; var result = twoThousand + one; // C# 自動隱式轉換，合法 int three = 3; double pointOne = 0.14159; var pi = three + pointOne; // C# 自動將 int 轉為 double，合法 關鍵差異分析：\n語法面：Swift 使用建構式語法 Type(value) 進行轉換；C# 使用轉型語法 (Type)value 或 Convert.ToType(value)。 行為面：這是 C# 開發者最容易遇到的編譯錯誤。C# 習慣 int + double 自動變 double，但在 Swift 中這會報錯。Swift 設計哲學認為隱式轉換是 Bug 的溫床。 型別細節： Swift 的 Int 取決於平台（64-bit 平台上是 64-bit）。 C# 的 int 永遠是 32-bit (Int32)。C# 9.0 後的 nint 才相當於 Swift 的 Int。 元組 (Tuples) # 1. 核心觀念 # 概念解說：Tuple 允許將多個值組合成一個複合值。非常適合用於函式回傳多個結果，而不需要為此建立一個新的 Struct 或 Class。 關鍵語法：(Val1, Val2), .0, .1, (name: Val) 2. 範例解析 # 文件原始碼：\nlet http404Error = (404, \u0026#34;Not Found\u0026#34;) let (statusCode, statusMessage) = http404Error print(\u0026#34;The status code is \\(statusCode)\u0026#34;) // 使用索引存取 print(\u0026#34;The status code is \\(http404Error.0)\u0026#34;) // 命名元素 let http200Status = (statusCode: 200, description: \u0026#34;OK\u0026#34;) print(\u0026#34;The status code is \\(http200Status.statusCode)\u0026#34;) 邏輯解說： Tuples 可以解構 (Decompose) 成單獨的常數，也可以透過索引 (.0) 或標籤名稱 (.statusCode) 存取。\n3. C# 開發者視角 # 概念對應：對應現代 C# (C# 7.0+) 的 ValueTuple。\nC# 對照程式碼：\n// C# var http404Error = (404, \u0026#34;Not Found\u0026#34;); var (statusCode, statusMessage) = http404Error; // 解構 // 命名元素 var http200Status = (StatusCode: 200, Description: \u0026#34;OK\u0026#34;); Console.WriteLine(http200Status.StatusCode); 關鍵差異分析：\n語法面：兩者語法驚人地相似。 行為面：Swift 的 Tuple 和 C# 的 ValueTuple 都是 Value Type。但 Swift 官方建議 Tuple 僅用於臨時數據組合（如函式回傳），若資料結構複雜，應轉用 struct 或 class。 選項型別 (Optionals) # 1. 核心觀念 # 概念解說：這是 Swift 最重要的特性。Optional 代表「可能有值，也可能完全沒有值 (nil)」。Swift 的普通型別（如 Int, String）絕對不能是 nil。要處理缺失值，必須加上 ? 變成 Optional。 關鍵語法：Type?, nil, if let, !, ?? 官方提示： 在 Objective-C 中，nil 指向一個不存在的物件指標；在 Swift 中，nil 不是指標，而是代表「值不存在 (Absence of a value)」的一種狀態。任何型別（包括 Int）都可以是 Optional。\n2. 範例解析 # 文件原始碼：\nvar serverResponseCode: Int? = 404 serverResponseCode = nil // 現在沒有值了 // Optional Binding (安全解包) if let actualNumber = Int(\u0026#34;123\u0026#34;) { print(\u0026#34;Has value: \\(actualNumber)\u0026#34;) } else { print(\u0026#34;Conversion failed\u0026#34;) } // Implicitly Unwrapped Optionals (隱式解包) let assumedString: String! = \u0026#34;Always has value\u0026#34; let implicitString: String = assumedString // 自動解包，不需 ! 邏輯解說：\nInt(\u0026quot;123\u0026quot;) 回傳的是 Int?，因為轉換可能失敗。 if let 是 Swift 特有的語法，用於檢查 Optional 是否有值，若有則解包並賦值給臨時常數 actualNumber，該常數在 if 區塊內是安全的非 Optional 型別。 String! 用於那些「宣告後保證一直有值」的情況（如 UI 元件初始化後），使用時不用每次都解包，但若為 nil 會導致 Crash。 3. C# 開發者視角 # 概念對應：\n類似 C# 的 Nullable\u0026lt;T\u0026gt; (int?) 以及 C# 8.0+ 的 Nullable Reference Types (string?)。 但 Swift 的 Optional 實作上是一個 Enum (Case None, Case Some(Wrapped)). C# 對照程式碼：\n// C# int? serverResponseCode = 404; serverResponseCode = null; // C# 模式匹配 (類似 Swift 的 if let) string possibleNumber = \u0026#34;123\u0026#34;; if (int.TryParse(possibleNumber, out int actualNumber)) { Console.WriteLine($\u0026#34;Has value: {actualNumber}\u0026#34;); } // 或者對於 Nullable Types if (serverResponseCode is int code) { // code 在此處為 int，非 int? } // C# 沒有 Implicitly Unwrapped Optionals (!) 的直接對應 // 通常用 string! 告訴編譯器 \u0026#34;我知道這不是 null\u0026#34; (Null-forgiving operator) 關鍵差異分析：\n語法面：Swift 的 if let x = opt 語法非常簡潔。C# 需要使用 is 模式匹配 if (opt is {} x) 來達到類似效果。 行為面： C# 的 Reference Types 預設仍可能為 null (除非開啟 nullable context 並忽略警告)，Runtime 仍可能拋出 NullReferenceException。 Swift 透過編譯器強制檢查，如果不解包 (Unwrap) 就無法使用 Optional 裡面的值，從根本上杜絕了意外的 Null Reference 錯誤。 強制解包：Swift 的 ! (Force Unwrap) 若遇上 nil 會直接 Crash；類似 C# 的 .Value 存取但在空值時拋出異常。 錯誤處理 (Error Handling) # 1. 核心觀念 # 概念解說：Swift 使用 throws、try、do-catch 來處理可預期的錯誤。這與 Optionals 不同，Optionals 處理「值的缺失」，Error Handling 處理「操作失敗的原因」。 關鍵語法：throws, try, do { ... } catch { ... } 2. 範例解析 # 文件原始碼：\nfunc makeASandwich() throws { // ... 可能拋出錯誤 } do { try makeASandwich() eatASandwich() } catch SandwichError.outOfCleanDishes { washDishes() } catch SandwichError.missingIngredients(let ingredients) { buyGroceries(ingredients) } 邏輯解說： 函式宣告 throws 表示它可能會失敗。呼叫時必須在前面加 try，並包在 do-catch 區塊中處理異常。Swift 的錯誤通常是 Enum，可以攜帶關聯值（如 missingIngredients 帶出的清單）。\n3. C# 開發者視角 # 概念對應：對應 C# 的 try-catch 機制。\nC# 對照程式碼：\n// C# void MakeASandwich() { // ... throw new Exception(...) } try { MakeASandwich(); EatASandwich(); } catch (OutOfCleanDishesException) { WashDishes(); } catch (MissingIngredientsException ex) { BuyGroceries(ex.Ingredients); } 關鍵差異分析：\n語法面：Swift 要求在呼叫點明確寫出 try，這讓開發者一眼就能看出哪行程式碼可能拋出錯誤，C# 則隱式拋出。 行為面：C# 的 Exception 是昂貴的物件（包含 Stack Trace）；Swift 的 Error 通常是輕量級的 Struct 或 Enum，效能開銷極低，因此在 Swift 中用 Error 做流程控制是可以接受的。 斷言與前置條件 (Assertions and Preconditions) # 1. 核心觀念 # 概念解說：用於執行期間檢查邏輯假設。如果條件為 false，程式會終止。這是除錯與確保程式狀態正確的重要工具。 關鍵語法：assert (僅 Debug 模式生效), precondition (Debug 與 Release 皆生效) 2. 範例解析 # 文件原始碼：\nlet age = -3 assert(age \u0026gt;= 0, \u0026#34;A person\u0026#39;s age can\u0026#39;t be less than zero.\u0026#34;) // 在 Debug 模式下會觸發 Crash // Index 檢查 precondition(index \u0026gt; 0, \u0026#34;Index must be greater than zero.\u0026#34;) 3. C# 開發者視角 # 概念對應：\nSwift assert 對應 C# Debug.Assert。 Swift precondition 對應 C# Trace.Assert 或手動 if (!cond) throw ...。 C# 對照程式碼：\n// C# using System.Diagnostics; int age = -3; Debug.Assert(age \u0026gt;= 0, \u0026#34;A person\u0026#39;s age can\u0026#39;t be less than zero.\u0026#34;); 關鍵差異分析：\nSwift 明確區分了「僅除錯用 (assert)」和「生產環境也要檢查 (precondition)」的語法，C# 通常依賴 System.Diagnostics 命名空間或合約 (Contracts) 來處理。 ","date":"2026.01.22","externalUrl":null,"permalink":"/dev/swift/from-csharp-to-swift/thebasics/","section":"Devs","summary":"","title":"[從C#到Swift] 01. The Basics","type":"dev"},{"content":"","date":"2026.01.10","externalUrl":null,"permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"Blowfish","type":"tags"},{"content":"","date":"2026.01.10","externalUrl":null,"permalink":"/tags/cloudflare/","section":"Tags","summary":"","title":"Cloudflare","type":"tags"},{"content":"","date":"2026.01.10","externalUrl":null,"permalink":"/tags/github-pages/","section":"Tags","summary":"","title":"Github-Pages","type":"tags"},{"content":"","date":"2026.01.10","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2026.01.10","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2026.01.10","externalUrl":null,"permalink":"/tags/static-site/","section":"Tags","summary":"","title":"Static-Site","type":"tags"},{"content":"","date":"2026.01.10","externalUrl":null,"permalink":"/categories/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98/","section":"Categories","summary":"","title":"技術筆記","type":"categories"},{"content":" 這篇筆記整理了使用 Hugo（靜態網站生成器）搭配 Blowfish主題，管於 GitHub Pages，並在Cloudflare設定網域。\n準備 # 安裝 Node.js # Node.js: 前往 Node.js 官網 下載並安裝。 安裝 Hugo # Hugo (Windows): install Hugo\nwinget install Hugo.Hugo.Extended 安裝Blowfish工具 # 使用官方推薦的 CLI 工具來初始化主題，這能簡化很多依賴設定。\n提示：詳細步驟可參考 Blowfish 官方文檔。\n配置 # Blowfish基礎配置 # 開始\n配置\n站點級配置 (hugo.toml) # baseURL: 最關鍵的參數。 baseURL 必須被設置為最終的公開域名（例如 https://www.example.com/）。如果設置錯誤，部署後會導致 CSS/JS 路徑失效，網站變成「裸奔」狀態（樣式丟失）甚至出現 404 錯誤。\nlanguageCode: 設置為 zh-tw，這有利於 SEO 與瀏覽器翻譯識別。 目錄結構解析 # 目錄名稱 功能描述 重要性 config/ 存放配置文件 強烈建議拆分為多個檔案（如 languages.zh-tw.toml），以支持多語言配置。 content/ 存放文章內容 網站的靈魂。資料夾結構直接對應網址路徑。 static/ 存放靜態資源 這裡的檔案（如圖片、CNAME）會被原封不動複製到發布目錄。 assets/ 資源處理 存放需要的檔案。 多語言與選單 # 在 config/_default/languages.zh-tw.toml 中定義網站標題與作者資訊；在 menus.zh-tw.toml 中定義導航欄。利用 weight 參數控制排序，數值越小越靠前。\n自動化部署：GitHub Pages # 不需要每次手動 build 完再上傳，讓 GitHub Actions 代勞，實現「推代碼即部署」。\n建立 Workflow 檔案 # 官方文件\n請在專案根目錄建立檔案 .github/workflows/gh-pages.yml，並填入自動化部署的配置內容（定義 Build 與 Deploy 到 gh-pages 分支的流程）。\n注意需加入 jobs.build-deploy.permissions.contents : write ，否則 Action 會因權限不足而失敗。\n# .github/workflows/gh-pages.yml name: GitHub Pages on: push: branches: - main jobs: build-deploy: permissions: contents: write runs-on: ubuntu-24.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: gh-pages publish_dir: ./public .gitignore # 為了保持 Git 倉庫乾淨，請設定忽略生成目錄與暫存檔。\n# Hugo default output directory /public /resources/_gen # Hugo build lock .hugo_build.lock 簡易版的自動提交腳本 # 為了節省每次輸入 git 指令的時間，用一個簡單的 PowerShell 腳本 (deploy.ps1)：\nparam( [Parameter(Mandatory=$false)] [string]$msg = \u0026#34;Site update $(Get-Date -Format \u0026#39;yyyy-MM-dd HH:mm\u0026#39;)\u0026#34; ) # 執行 git add Write-Host \u0026#34;正在加入變更至暫存區 (git add)...\u0026#34; -ForegroundColor Cyan git add . # 檢查是否有變更需要提交 if ($(git status --porcelain)) { # 執行 git commit Write-Host \u0026#34;正在提交變更 (git commit)...\u0026#34; -ForegroundColor Cyan git commit -m \u0026#34;$msg\u0026#34; # 執行 git push Write-Host \u0026#34;正在推送至遠端 (git push)...\u0026#34; -ForegroundColor Cyan git push Write-Host \u0026#34;完成！\u0026#34; -ForegroundColor Green } else { Write-Host \u0026#34;沒有偵測到需要提交的變更。\u0026#34; -ForegroundColor Yellow } 設定 GitHub Pages 來源 # 將代碼推送到 GitHub 後，等待 Action 執行成功，接著必須手動啟用 Pages 服務：\n進入 GitHub Repo 的 Settings。 點擊左側側邊欄的 Pages。 在 Build and deployment 區域： Source: 選擇 Deploy from a branch。 Branch: 選擇 gh-pages 分支 (如果沒看到，請確認 Action 是否已成功跑完)。 Folder: 選擇 / (root)。 點擊 Save。 網域綁定：Cloudflare 與 CNAME # Cloudflare DNS 設定 # 購買網域後，使用 Cloudflare 來管理 DNS\nGithub教學\nApex Domain (根域名 example.com): 新增 4 筆 A 記錄，指向 GitHub Pages 的專用 IP：\n185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 Subdomain (子域名 www): 新增 1 筆 CNAME 記錄：\n名稱: www 內容: \u0026lt;你的GitHub用戶名\u0026gt;.github.io 關鍵一步：手動建立 CNAME 文件 # 這是一個極易被忽略！ 當你在 GitHub 網頁上設定 Custom Domain 後，GitHub 會自動產生一個 CNAME 檔。但因為我們的部署流程是「每次重新生成並覆蓋」，下一次 Hugo 部署時，這個檔案會被刪除，導致網域失效。\n解決方案： 必須在本地專案的 static/ 目錄下手動建立一個名為 CNAME 的檔案（無副檔名），內容只需一行，請填入你的網域，範例如下：\nexample.com **原理：**Hugo 在構建時，會將 static/ 目錄下的所有文件原封不動地複製到 ./public。這確保了每次 Action 構建後，CNAME 文件都會存在，從而持久化網域綁定配置。\nGitHub Pages 設定 # 回到 GitHub Repo 的 Settings \u0026gt; Pages \u0026gt; Custom domain，填入你的網域（如 example.com），等待 \u0026ldquo;DNS check successful\u0026rdquo;。\n總結與檢查清單 # 完成上述步驟後，你的網站應該已經順利上線了。最後，請對照這份清單進行最終確認：\nhugo.toml: baseURL 是否已改為你的正式網域？\nstatic/CNAME: 文件是否存在且內容正確？\nGitHub Settings: Pages 頁面是否顯示 \u0026ldquo;DNS check successful\u0026rdquo;？\n","date":"2026.01.10","externalUrl":null,"permalink":"/posts/notes/hugo-blowfish-github-pages-guide/","section":"Posts","summary":"","title":"從零開始 : Hugo + GitHub Pages + Cloudflare 架站筆記","type":"posts"},{"content":" 引言：你是在「閱讀」，還是在「被動接收」？ # 在這個資訊爆炸的時代，我們每天都在閱讀——社群貼文、新聞快訊、技術文件。但你是否曾有過這樣的經驗：花了好幾個小時讀完一本書，蓋上書本後卻腦袋一片空白，只記得「感覺很棒」，卻說不出具體的邏輯或應用？\n莫提默‧艾德勒（Mortimer J. Adler）與查理‧范多倫（Charles Van Doren）合著的經典之作《如何閱讀一本書》，一針見血地指出：「閱讀的重點不在客觀的文字，而在讀者主動解讀文字的過程。」\n如果不願意動用主動的態度，我們只是資訊的容器，而非知識的主人。這篇筆記將重新梳理書中的核心架構，帶你從「資訊獲取」進階到真正的「深度理解」。\n核心觀點一：閱讀是主動的「接球」遊戲 # 作者認為，閱讀是一件主動的事。完全的被動只能說是「認字」，而非「閱讀」。\n如果把寫作比喻為投手投球，閱讀就是捕手接球。你必須張開感官、動用記憶力，主動去捕捉作者想要傳達的訊息。若我們只是被動地掃視文字，就像是球飛過來了，我們卻站在原地不動，最終什麼也沒接到。\n我們必須區分兩種閱讀目標：\n為獲得資訊而讀：讀我們原本就讀得懂的東西，增加的是資訊量。 為求得理解而讀：讀那些我們略感吃力、必須深思熟慮才能懂的東西。 真正的學習發生在後者。 這是憑藉一己之力，將理解力從粗淺推進到深入的過程。\n核心觀點二：閱讀的四個層次 # 這本書最精華的部分，在於將閱讀分為四個漸進的層次。這不是四種獨立的方法，而是像洋蔥一樣，高層次包含了低層次的能力。\n1. 基礎閱讀 # 這是小學階段的目標，重點在於「認字」。能讀懂句子在說什麼，是所有閱讀的基石。\n2. 檢視閱讀 # 這是在有限時間內，抓出一本書重點的藝術。\n略讀：先看書名、序言、目錄、索引，快速翻閱與主題相關的篇章。 粗淺的閱讀：遇到難讀的書，先從頭到尾讀一遍，碰到不懂的地方不要停下來查詢或思索。 目的：這階段不求甚解，目標是發現這本書的「骨架」與「脈動」。 3. 分析閱讀 # 這是最完整、最優質的閱讀方式，也是將書本「吃透」的關鍵。作者提出了詳細的規則，我將其歸納為三個重點步驟：\n透視架構：用一句話或一段文字敘述整本書在談什麼（找出主題），並列出大綱（找出骨架）。 詮釋內容： 關鍵字（Terms）：找出與作者共通的詞彙，解決「定義」問題。 主旨（Propositions）：找出關鍵句，用自己的話重述作者的判斷。 論述（Arguments）：分析作者是用歸納法還是演繹法來證明觀點。 公正評斷：在說出「我同意」或「我反對」之前，你必須先說「我讀懂了」。反對時要有理有據（證明作者知識不足、知識錯誤、不合邏輯或分析不完整）。 4. 主題閱讀 # 這是閱讀的最高境界，也是專業研究者的必備技能。\n以「我」為主：這時，你關心的不是某一本書，而是「你自己想解決的問題」。 整合觀點：閱讀多本書，建立一套中立的詞彙，讓不同的作者在你的架構下進行對話。 釐清爭議：整理不同作者對同一議題的衝突觀點，最後建立你自己的結論。 核心觀點三：主動閱讀者的四個提問 # 要如何保持「主動」？作者建議在閱讀過程中，不斷自我提問：\n整體來說，這本書到底在談些什麼？（找出主題與核心） 作者細部說了什麼？怎麼說的？（找出主要的想法、聲明與論點） 這本書說的有道理嗎？是全部有道理，還是部份有道理？（進行批判性思考） 這本書跟你有什麼關係？（這是我認為最重要的一點，知識必須與生命經驗連結） 精選金句 # 「閱讀的藝術在於掌握住作者傳達的訊息。」\n「只有一種方式是真正的閱讀，不要有任何外力的幫助，就是要讀這本書，從模糊的概念到更清楚的理解為止。」\n「書成為你的一部分和你成為書的一部分是同一件事，就是要去寫下來。」\n「最能學習的讀者，也就是最能批判的讀者。」\n個人反思與總結：為什麼我們要寫筆記？ # 讀完這本書，我對「做筆記」這件事有了全新的理解。\n以前我認為做筆記是為了「紀錄」，怕忘記書裡的內容。但《如何閱讀一本書》告訴我，筆記是為了「對話」。\n書中提到：「必須要讀出言外之意，才會有更大的收穫。」當我們試著用自己的語言去重述作者的主旨（分析閱讀），或是將多本書的觀點打散重組（主題閱讀）時，我們就不再只是資訊的接收者，而是知識的生產者。\n如果你覺得一本書很難讀，那是好事，因為那代表你的理解力正在被「拉升」。\n給自己的行動指南：\n遇難不退：讀第一遍時，遇到不懂的專有名詞先跳過，不要打斷閱讀的流暢感（檢視閱讀）。 用自己的話說：如果我無法用自己的語言解釋一個概念，代表我根本沒懂，只是記住了作者的「字」。 建立輸出循環：就像現在這篇文章一樣，將閱讀筆記整理成有邏輯的部落格文章，是檢驗自己是否完成「分析閱讀」的最好方式。 閱讀，就是讓大腦去健身房重訓。願我們都能透過閱讀，讓生活過得格外豐富濃稠。\n","date":"2024.02.12","externalUrl":null,"permalink":"/posts/book/how-to-read-a-book/","section":"Posts","summary":"","title":"如何閱讀一本書","type":"posts"},{"content":"","date":"2024.02.12","externalUrl":null,"permalink":"/tags/%E5%A6%82%E4%BD%95%E9%96%B1%E8%AE%80%E4%B8%80%E6%9C%AC%E6%9B%B8/","section":"Tags","summary":"","title":"如何閱讀一本書","type":"tags"},{"content":"","date":"2024.02.12","externalUrl":null,"permalink":"/tags/%E6%9F%A5%E7%90%86%E8%8C%83%E5%A4%9A%E5%80%AB/","section":"Tags","summary":"","title":"查理‧范多倫","type":"tags"},{"content":"","date":"2024.02.12","externalUrl":null,"permalink":"/tags/%E8%8E%AB%E6%8F%90%E9%BB%98%E8%89%BE%E5%BE%B7%E5%8B%92/","section":"Tags","summary":"","title":"莫提默‧艾德勒","type":"tags"},{"content":"","date":"2024.02.12","externalUrl":null,"permalink":"/categories/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/","section":"Categories","summary":"","title":"閱讀筆記","type":"categories"},{"content":"","date":"2024.02.05","externalUrl":null,"permalink":"/tags/%E7%B4%8D%E7%93%A6%E7%88%BE/","section":"Tags","summary":"","title":"納瓦爾","type":"tags"},{"content":" 《納瓦爾寶典》並不是一本教你如何快速致富的工具書，而是一本關於「人生哲學」的指南 # 在這個資訊焦慮、每個人都急著想「變現」的時代，我們往往陷入了忙碌卻無效的循環。我們出賣時間換取金錢，卻發現財富自由遙遙無期；我們追求外在的物質滿足，卻發現內心的平靜越來越難獲得。\n核心觀點一：財富的本質與「把自己商品化」 # Naval 提出了一個震撼的觀點：「在還沒弄清楚自己應該努力的事情之前，你不應該把許多笨苦工當作磨練。」 努力只是必要條件，但「選擇」比努力更重要。\n1. 什麼是財富？ # 金錢只是轉移財富的工具，財富是你睡覺時也能幫你賺錢的資產（如程式碼、媒體內容、股票）。如果你必須親自到場才能賺錢，那你只是擁有一份工作，而不是擁有財富。\n2. 獨特知識 (Specific Knowledge) # 要在市場上勝出，你不能跟別人做一樣的事。你必須找到你的獨特知識：\n無法被輕易培訓：如果學校能教，別人就能輕易學會並取代你。 源於熱愛：對你來說像在玩樂，對別人來說卻是在工作。 實作中獲得：通常透過師徒制或自我探索，而非正規教育。 3. 三種槓桿 (Leverage) # 擁有獨特知識後，你需要槓桿來放大你的產出。Naval 將槓桿分為三類：\n勞動力槓桿：讓別人為你工作。這是最古老但也是最難管理的槓桿。 資本槓桿：用錢賺錢。這需要你有良好的判斷力來募集資金。 零邊際成本的槓桿（新時代的聖杯）： 程式碼 (Code)：寫軟體。 媒體 (Media)：寫書、部落格、錄製 Podcast、影片。 這兩者是**「無需許可」(Permissionless)** 的槓桿。你不需要別人的同意就能使用，且複製成本為零。\n總結公式：\n把自己商品化 = 獨特知識 + 責任 (Accountability) + 槓桿\n核心觀點二：培養判斷力與長期賽局 # 為什麼有些人能在關鍵時刻做出正確決定，而有些人總是忙於修正錯誤？差別在於判斷力。\n1. 判斷力勝過蠻力 # 在現代社會，方向正確比行動迅速更重要。巴菲特可能花一年思考，只用一天行動，但那天的行動能影響未來數十年。\n預留空白：在忙碌行程中留白，給自己思考的時間。 去除雜訊：避免自我意識 (Ego) 和情緒干擾決策。 基礎學科：學習微觀經濟學、賽局理論、心理學、數學和電腦科學。這些基礎知識能幫助你建立穩固的思維模型。 2. 玩長期的複利賽局 # 生命中所有的回報（財富、關係、知識）都來自複利。\n選擇戰場：選擇可以和長期夥伴一起玩長期賽局的產業。 誠信至上：選擇智商高、能力強，但最重要的是有誠信的合作夥伴。 避開負面：遠離憤世濟俗和悲觀的人，因為他們會讓悲劇成真。 核心觀點三：快樂是一種可以學習的技能 # 我們常誤以為快樂是達成目標後的獎賞，但 Naval 認為：「快樂是一種選擇，是一種高度個人化的能力。」\n1. 慾望的代價 # Naval 說出一句極具洞察力的話：\n「慾望是你跟自己訂下的契約：在得到想要的東西之前，你不會快樂。」\n我們不需要透過苦行僧的方式生活，但要意識到每一個慾望都是對當下平靜的干擾。選擇一個最重要的慾望去追求，然後對其他事物保持平靜。\n2. 活在當下 # 除了此時此刻，我們其實別無所有。焦慮通常來自對未來的擔憂，悔恨來自對過去的糾結。\n冥想：这是大腦的「間歇性斷食」與「除錯模式」。 改變、接受或離開：面對任何情況，你永遠只有這三種選擇。如果你不能改變它，也不能離開它，那就徹底接受它。 個人反思與總結 # 讀完《納瓦爾寶典》，最大的啟發在於**「槓桿」**觀念的轉變。\nNaval 提醒我們，人生的終極目標不是成為最富有的人，而是成為**「做自己生命的主人」**。願我們都能運用槓桿，拿回時間的自主權。\n","date":"2024.02.05","externalUrl":null,"permalink":"/posts/book/the-almanack-of-naval-ravikant/","section":"Posts","summary":"","title":"納瓦爾寶典","type":"posts"},{"content":"","date":"2024.02.05","externalUrl":null,"permalink":"/tags/%E7%B4%8D%E7%93%A6%E7%88%BE%E5%AF%B6%E5%85%B8/","section":"Tags","summary":"","title":"納瓦爾寶典","type":"tags"},{"content":" 《心流：最優體驗心理學》讀書筆記：掌控意識，重塑生活的幸福感 # 在這個物質生活飛速進步，但焦慮與空虛感卻日益蔓延的時代，我們該如何定義幸福？\n米哈里．契克森米哈伊（Mihaly Csikszentmihalyi）在《心流：最優體驗心理學》一書中給出了一個反直覺的答案：幸福與外在條件無關，而是取決於我們如何詮釋它。這是我在閱讀本書後，關於如何掌控意識、創造「最優體驗」的深度筆記。\n重新詮釋幸福與成功 # 許多人終其一生追求外在的成功標籤，卻往往在達到目標後感到失落。奧地利心理學家維克多．弗蘭克（Viktor Frankl）曾說過一句極具啟發性的話：\n「不要以成功為目標——當你越是針對它，以它為標的，就越容易錯過它。成功，就像幸福一樣，不是追求而來的；它是一個人全心全意投入一件事，而忘卻自我的副產物。」\n這正是「心流」（Flow）的核心概念。最美好的時刻，並非發生在放鬆休閒時，而是發生在一個人有意地將身體或心智能力發揮到極限，去完成某件有難度或有價值的事。\n在此過程中，我們會進入一種全神貫注、渾然忘我的境界。要達到這種境界，我們必須將全部的精神能量投注在一個「符合現實」的目標上，且自身的技能必須與行動相互配合。\n解析意識：資訊的秩序 # 意識並無神秘之處，它是生理作用的產物。我們可以將意識視為「經過刻意整理的資訊」。\n意識的力量： 人類的神經系統可以左右自己的狀態。不管外在環境如何，只要改變意識內容（轉念），就能改變快樂或痛苦的感受。 意圖（Intent）： 這是讓意識維持秩序的力量。它像磁場一樣，將我們的注意力導向特定事物。 注意力的循環： 注意力塑造了自我（例如：偶然注意到海洋之美），而自我反過來塑造注意力（開始刻意追求海洋生物學知識）。 處於最優體驗的人，會感到與目標一致的資訊不斷進入意識，精神能量源源不絕，不再自我懷疑。\n享樂 vs. 樂趣：生活品質的關鍵 # 改善生活品質有兩個策略：一是改變外在環境，二是改變體驗環境的方式。而後者往往更為關鍵，因為生活品質取決於我們如何看待自己與際遇。\n我們必須區分「享樂」與「樂趣」：\n享樂 (Pleasure)： 是一種生物需求或社會制約的滿足（如：吃大餐、看電視放鬆）。它能維持秩序，但無法創造新秩序。 樂趣 (Enjoyment)： 超乎原有的期待，具有向前發展的特性。它通常發生在從事一件艱難但有機會成功的事，能帶來新鮮感與成就感。 樂趣的八大要素 # 當活動具備以下特質時，最容易產生樂趣：\n從事一件艱難，但有機會成功的事（行動機會與個人能力相當）。 必須全神貫注。 有明確的目標。 有立即的回饋。 全心投入，忘卻平時的擔憂。 覺得對自己的行動有掌控權。 進入忘我境界（體驗結束後，自我感會更強烈）。 時間感扭曲（幾小時像幾分鐘，或反之）。 這就是所謂的「自成目標」（Autotelic）活動——活動本身即是目標，而非為了未來的某種獎賞。\n心流的觸發機制：挑戰與技能的黃金比例 # 心流之所以能讓人感到成長，是因為它迫使我們進入一個新的現實，使自我變得更複雜。觸發心流最關鍵的條件在於 「技能」與「挑戰」的匹配：\nA2 技能 \u0026gt; 挑戰： 感到無聊（Boredom）。 A3 挑戰 \u0026gt; 技能： 感到焦慮（Anxiety）。 A1、A4 技能 = 挑戰： 進入心流（Flow）。 當我們在活動中感到無聊，意味著我們該提高難度；感到焦慮，則意味著需要提升技能。這種動態平衡推動著我們不斷進步。\n培養「自得其樂」的性格 # 除了尋找適合的活動，培養一種能隨時重組意識的內在性格同樣重要。哲學家羅素（Bertrand Russell）曾描述這種狀態：\n「我學著無視自己的缺陷與存在；慢慢增加對外在事物的關注，像是世界的現狀、各種領域的知識、令我感興趣的人物。」\n家庭對心流能力的影響 # 研究發現，在「自成目標」家庭長大的孩子，更容易產生心流體驗。這樣的家庭具備五個特點：\n明確 (Clarity)： 孩子清楚知道父母的期待與回饋。 重心 (Centering)： 父母對孩子當下做的事感興趣，而非只關心未來的功利結果。 選擇 (Choice)： 孩子感覺自己擁有選擇權，並願承擔後果。 承諾 (Commitment)： 足夠的信任感讓孩子能放下防備，全心投入。 挑戰 (Challenge)： 父母提供複雜度逐漸提高的行動機會。 翻轉渾沌：將壓力轉化為力量 # 為什麼有些人遇到壓力會崩潰，有些人卻越挫越勇？關鍵在於是否具備將無助狀況轉換為可控心流活動的能力。\n這類人通常具備以下特質：\n不自覺的自信： 不堅持自己的目標非得凌駕一切，而是將自己視為環境的一部分，在此體系中盡責。這種謙卑的自信是強者的標誌。 焦點向外： 態度開放，保持客觀，不花時間自怨自艾，而是注意到環境中的可能性。 尋找解決之道： 聚焦於移除障礙，甚至調整目標以尋求和諧。 結語：創造意義 # 想要將生活的全部變成一場心流體驗，光懂得控制一時的意識狀態是不夠的。我們需要一個貫穿人生的整體目標。\n心流理論的最終任務，是在所做的每一件事上創造和諧。只要方向清楚，行動規則明確，並能讓我們專注投入，任何目標——無論大小——都能讓人的一生充滿意義，將人生整合成單一件宏大的心流活動。\n","date":"2024.01.30","externalUrl":null,"permalink":"/posts/book/flow/","section":"Posts","summary":"","title":"心流","type":"posts"},{"content":"","date":"2024.01.30","externalUrl":null,"permalink":"/tags/%E5%BF%83%E6%B5%81/","section":"Tags","summary":"","title":"心流","type":"tags"},{"content":"","date":"2024.01.30","externalUrl":null,"permalink":"/tags/%E7%B1%B3%E5%93%88%E9%87%8C%E5%A5%91%E5%85%8B%E6%A3%AE%E7%B1%B3%E5%93%88%E4%BC%8A/","section":"Tags","summary":"","title":"米哈里．契克森米哈伊","type":"tags"},{"content":" 叔本華《人生智慧箴言》讀書筆記：向內尋求的幸福哲學 # 前言 # 最近重讀了叔本華的《人生智慧箴言》（Aphorisms on the Wisdom of Life）。這本書並非探討深奧晦澀的形而上學，而是這位悲觀主義哲學家晚年對「如何幸福生存」最務實的建議。\n叔本華在書中冷靜地剖析了人性的弱點與世道的殘酷，並指出：人生在世，其實不是為了享受人生，而是為了度過它。 以下是我對這本書的重點筆記與思考整理。\n人的三大基本分類：幸福取決於「你是誰」 # 叔本華認為，人的命運與遭遇差別，取決於三項根本內容：\n人之所是（人格）： 指最廣義的人格，包含健康、力量、外貌、氣質、道德品格、心智及其培育。這是大自然賦予的，也是最本質的。 人之所有（財富）： 指各類物質財富與佔有物。 人的形象（名聲）： 一個人在他人眼中的樣子，包含名譽、地位與名聲。 核心洞見 # 「人之所是」是幸福的基石： 外在的財富與名聲（客體）由命運掌握，變動不居；但我們的主體（自我）是本質，不會改變。 世界的面貌取決於你的頭腦： 相同的外在事件，對不同的人有完全不同的影響。一個人生活在什麼樣的世界中，首先取決於他對世界的理解。 健康的壓倒性地位： 健康是第一位的佳品。所謂「健康的乞丐比病篤的國王更幸福」。 「我們力所能及的，唯有最大限度地利用我們的天賦人格。」\n關於痛苦與無聊 # 叔本華提出了一個著名的鐘擺理論：人生就是在「痛苦」與「無聊」之間擺盪。\n痛苦：源於缺乏（如貧困、窘迫）。 無聊：源於滿足（如平安、富足）。 當外在物質匱乏時，我們感到痛苦；當物質滿足後，若內心空虛，我們便感到無聊。 精神越豐富、越接近卓越的人，留給無聊的空間就越小。 唯有在閒暇時能無憂無慮地享受自己的意識與個性，才是真正的幸福；若無精神活動充實，閒暇就只是「活人的墳墓」。\n拔除肉中刺：降低對他人看法的敏感度 # 我們花費了太多生命在經營「人的形象」，這往往是幸福最大的敵人。\n內在 vs 外在： 我們真實的狀況（健康、家庭、心境）存在於我們自己的意識中；而名聲只存在於「別人的意識」中，對我們來說僅是間接存在。\n虛榮與驕傲的區別：\n驕傲：是發自內心的確信（相信自己有價值）。\n虛榮：是希望在他人心中喚起這種確信（從外部獲得評價）。\n最有效的幸福策略： 將對他人看法的關注度降到最低（例如降到目前的五十分之一）。這能拔掉時刻折磨我們的「肉中刺」。\n處世的具體忠告 # 關於生活態度 # 追求「無痛苦」而非「快樂」： 亞里斯多德說：「明智的人追求的是無痛苦，不是快樂。」快樂本質上是負面的（僅是慾望受阻的消除），而痛苦是正面的。要評估一個人多幸福，不該問什麼讓他快樂，而該問「什麼讓他悲傷」——讓他煩惱的事越微不足道，他的幸福度越高。 活在當下： 不要過分關注過去或未來，唯有「現在」真實不虛。 自足自樂： 能說出「我獨自承擔全部自我」的人，具備幸福的首要條件。 如何待人 # 人際關係充滿了無奈與偽裝，叔本華建議保持「謹慎」與「寬容」。\n接納與距離： 我們必須接納每個人的固有個性，因為他改變不了。但要記住，人只能理解與自己同層次的事物，大多數人「主觀透頂」，只關心與自己有關的事。 藏拙是智慧： 展現聰明才智並不會討人喜歡，反而會因為間接指責他人愚蠢而惹人厭惡。正如格拉希安所說：「要討人喜歡，唯一的辦法就是披上最蠢動物的皮。」 禮貌的本質： 禮貌是一種默契，彼此心照不宣地忽視對方的道德低下與心智貧困。 溝通的藝術： 不要反駁：因為無法說服一個人放棄他的謬誤。 不要糾正：即使出於善意也不要。 說話平淡：讓他人去領悟，不要訴諸感情。 應對命運 # 人生如棋： 命運負責發牌（決定事件），我們負責出牌（做出決定）。 運氣與變數： 萬事變動不居，禍福相依。幸運時不要欣喜若狂，厄運時不要悲痛欲絕。 勇氣： 除了明智，勇氣對幸福至關重要。 人生的不同時期 # 叔本華對人生的階段有著詩意而透徹的比喻：\n少年視角： 眼前是漫長無盡的未來。生活如詩歌，充滿直觀與鮮明的印象。 老年視角： 身後是短暫的過去。生活如哲學，充滿抽象的思考。 時間的流逝： 年齡越大，生命意識越薄弱，日子過得越快，就像一部看過千百遍的戲，熟視無睹。 晚年的解放： 只有到了晚年，才能真正獲得「無所敬畏」的平靜，看透世間榮華皆是虛妄。 結語 # 《人生智慧箴言》教導我們的，是一種向內尋求的智慧。\n我們往往向外尋求快樂，卻找到了教訓。真正的幸福，在於健康的身體、平靜的靈魂，以及對自身擁有的確認。如叔本華所言：「既無痛苦，也不覺無聊，本質上就實現了人世的幸福，因為其餘都是虛幻。」\n","date":"2024.01.29","externalUrl":null,"permalink":"/posts/book/schopenhauer-aphorisms-summary/","section":"Posts","summary":"","title":"人生智慧箴言","type":"posts"},{"content":"","date":"2024.01.29","externalUrl":null,"permalink":"/tags/%E5%8F%94%E6%9C%AC%E8%8F%AF/","section":"Tags","summary":"","title":"叔本華","type":"tags"},{"content":"","date":"2024.01.29","externalUrl":null,"permalink":"/tags/%E5%93%B2%E5%AD%B8/","section":"Tags","summary":"","title":"哲學","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]